{"remainingRequest":"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-loader/lib/index.js?{\"presets\":[[\"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-preset-docz/dist/index.js\",{\"flow\":true,\"typescript\":false,\"parseProps\":true}]],\"plugins\":[[\"/Users/noisemachines/dev/pixel-matrix/node_modules/docz-utils/lib/named-asset-import.js\",{\"loaderMap\":{\"svg\":{\"ReactComponent\":\"@svgr/webpack?-prettier,-svgo![path]\"}}}],\"/Users/noisemachines/dev/pixel-matrix/node_modules/react-hot-loader/babel.js\"],\"babelrc\":false,\"cacheCompression\":false,\"compact\":false}!/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js","dependencies":[{"path":"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js","mtime":1547704212396},{"path":"/Users/noisemachines/dev/pixel-matrix/node_modules/cache-loader/dist/cjs.js","mtime":1547744876783},{"path":"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-loader/lib/index.js","mtime":1547744876677}],"contextDependencies":[],"result":["(function () {\n  var enterModule = require('react-hot-loader').enterModule;\n\n  enterModule && enterModule(module);\n})();\n\nvar RGBA = {\n  channels: 4\n};\nexport var COLOR_PROFILES = {\n  RGBA: RGBA\n};\n\nvar isEven = function isEven(n) {\n  return n % 2 === 0;\n};\n\nvar EMPTY_PIXEL = {\n  red: 0,\n  green: 0,\n  blue: 0,\n  alpha: 0\n};\nexport var vonNeumannOffsets = [{\n  x: -1,\n  y: 0\n}, {\n  x: 1,\n  y: 0\n}, {\n  x: 0,\n  y: -1\n}, {\n  x: 0,\n  y: 1\n}];\nexport var mooreOffsets = [];\n\nfor (var x = -1; x <= 1; x++) {\n  for (var y = -1; y <= 1; y++) {\n    if (x === 0 && y === 0) {\n      continue;\n    }\n\n    mooreOffsets.push({\n      x: x,\n      y: y\n    });\n  }\n}\n\nvar PixelMatrix =\n/** @class */\nfunction () {\n  function PixelMatrix(width, height, colorProfile, pixels) {\n    if (colorProfile === void 0) {\n      colorProfile = RGBA;\n    }\n\n    this.width = width;\n    this.height = height;\n    this.colorProfile = colorProfile;\n    var pixelsLength = width * height * colorProfile.channels;\n\n    if (pixels === undefined) {\n      pixels = new Uint8ClampedArray(pixelsLength);\n    } else {\n      if (pixelsLength !== pixels.length) {\n        throw new Error(\"Expected pixels to have length \" + pixelsLength + \" (width * height * colorProfile.channels) but got \" + pixels.length + \" instead.\");\n      }\n    }\n\n    this.pixels = pixels;\n  }\n\n  PixelMatrix.fromCanvas = function (canvas) {\n    var context = canvas.getContext('2d');\n    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    return new PixelMatrix(canvas.width, canvas.height, COLOR_PROFILES.RGBA, imageData.data);\n  };\n\n  Object.defineProperty(PixelMatrix.prototype, \"pixelMatrix\", {\n    get: function get() {\n      if (!this._pixelMatrix) {\n        var pixelMatrix_1 = new Array(this.width);\n        this.forEach(function (pixel, point) {\n          if (!pixelMatrix_1[point.x]) pixelMatrix_1[point.x] = [];\n          pixelMatrix_1[point.x][point.y] = pixel;\n        });\n        this._pixelMatrix = pixelMatrix_1;\n      }\n\n      return this._pixelMatrix;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PixelMatrix.prototype, \"channels\", {\n    get: function get() {\n      return this.colorProfile.channels;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PixelMatrix.prototype, \"shape\", {\n    get: function get() {\n      return [this.width, this.height];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PixelMatrix.prototype, \"countPixels\", {\n    get: function get() {\n      return this.width * this.height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  PixelMatrix.prototype.get = function (point) {\n    if (!this.contains(point)) {\n      throw new Error(\"This pixel matrix doesn't contain the point \" + point + \".\");\n    }\n\n    var i = this.getIndex(point);\n    var channels = [];\n\n    for (var channelOffset = 0; channelOffset < this.colorProfile.channels; channelOffset++) {\n      var channel = this.pixels[i + channelOffset];\n      if (!channel) return EMPTY_PIXEL;\n      channels.push(channel);\n    }\n\n    var red = channels[0],\n        green = channels[1],\n        blue = channels[2],\n        alpha = channels[3];\n    return {\n      red: red,\n      green: green,\n      blue: blue,\n      alpha: alpha\n    };\n  };\n\n  PixelMatrix.prototype.getRandomPoint = function () {\n    var x = Math.round(Math.random() * (this.width - 1));\n    var y = Math.round(Math.random() * (this.height - 1));\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  PixelMatrix.prototype.getRandomPixel = function () {\n    var randomPoint = this.getRandomPoint();\n    return this.get(randomPoint);\n  };\n\n  PixelMatrix.prototype.getVonNeumannNeighboringPixels = function (point) {\n    return this.getNeighboringPixels(point, vonNeumannOffsets);\n  };\n\n  PixelMatrix.prototype.getVonNeumannNeighboringPoints = function (point) {\n    return this.getNeighbors(point, vonNeumannOffsets);\n  };\n\n  PixelMatrix.prototype.getMooreNeighboringPixels = function (point) {\n    return this.getNeighboringPixels(point, mooreOffsets);\n  };\n\n  PixelMatrix.prototype.getMooreNeighboringPoints = function (point) {\n    return this.getNeighbors(point, mooreOffsets);\n  };\n\n  PixelMatrix.prototype.getNeighboringPixels = function (point, neighborhood) {\n    var _this = this;\n\n    return this.getNeighbors(point, neighborhood).map(function (neighbor) {\n      return _this.get(neighbor);\n    });\n  };\n\n  PixelMatrix.prototype.getNeighbors = function (point, neighborhood) {\n    var _this = this;\n\n    var neighbors = [];\n    neighborhood.forEach(function (offset) {\n      var neighbor = {\n        x: point.x + offset.x,\n        y: point.y + offset.y\n      };\n\n      if (_this.contains(neighbor)) {\n        neighbors.push(neighbor);\n      }\n    });\n    return neighbors;\n  };\n\n  PixelMatrix.prototype.set = function (point, pixel) {\n    var red = pixel.red,\n        green = pixel.green,\n        blue = pixel.blue,\n        alpha = pixel.alpha;\n    var i = this.getIndex(point);\n    this.pixels[i] = red;\n    this.pixels[i + 1] = green;\n    this.pixels[i + 2] = blue;\n    this.pixels[i + 3] = alpha;\n    this.pixelMatrix[point.x][point.y] = pixel;\n  };\n\n  PixelMatrix.prototype.randomDitherFrom = function (newMatrix, samples) {\n    var _this = this;\n\n    if (samples === void 0) {\n      samples = 1000;\n    }\n\n    var _loop_1 = function _loop_1(_) {\n      var point = this_1.getRandomPoint();\n      var newPixel = newMatrix.get(point);\n      var p = newPixel;\n      var darkeningFactor = 0;\n\n      if (Math.random() > 0.5) {\n        p = {\n          red: newPixel.red - darkeningFactor,\n          green: newPixel.green - darkeningFactor,\n          blue: newPixel.blue - darkeningFactor,\n          alpha: 255\n        };\n      }\n\n      this_1.getVonNeumannNeighboringPoints(point).forEach(function (neighbor) {\n        _this.set(neighbor, p);\n      });\n    };\n\n    var this_1 = this;\n\n    for (var _ = 0; _ < samples; _++) {\n      _loop_1(_);\n    }\n  };\n\n  PixelMatrix.prototype.getIndex = function (point) {\n    var x = point.x,\n        y = point.y;\n\n    if (!this.contains(point)) {\n      throw new Error(\"Expected x and y to be less than or equal to (\" + this.width + \", \" + this.height + \") but was actually (\" + x + \", \" + y + \")\");\n    }\n\n    return y * (this.width * this.channels) + x * this.channels;\n  };\n\n  PixelMatrix.prototype.forEach = function (fn) {\n    for (var y = 0; y < this.height; y++) {\n      for (var x = 0; x < this.width; x++) {\n        var point = Object.freeze({\n          x: x,\n          y: y\n        });\n        var pixel = this.get(point);\n        fn(pixel, point, this);\n      }\n    }\n  };\n\n  PixelMatrix.prototype.map = function (fn) {\n    var newPixelMatrix = new PixelMatrix(this.width, this.height, this.colorProfile);\n    this.forEach(function (pixel, point, pixelMatrix) {\n      var newPixel = fn(pixel, point, pixelMatrix);\n      newPixelMatrix.set(point, newPixel);\n    });\n    return newPixelMatrix;\n  };\n\n  PixelMatrix.prototype.normalizedMap = function (fn) {\n    var _this = this;\n\n    return this.map(function (pixel, point, pixelMatrix) {\n      var normalizedPoint = {\n        x: point.x / _this.width,\n        y: point.y / _this.height\n      };\n      return fn(pixel, normalizedPoint, pixelMatrix);\n    });\n  };\n\n  PixelMatrix.prototype.reduce = function (fn, startingValue) {\n    var total = startingValue;\n    this.forEach(function (pixel, point) {\n      total = fn(total, pixel, point);\n    });\n    return total;\n  };\n\n  PixelMatrix.prototype.getWindow = function (center, width, height) {\n    if (isEven(width)) {\n      throw new Error(\"Expected an odd window width, but got \" + width);\n    }\n\n    if (isEven(height)) {\n      throw new Error(\"Expected an odd window height, but got \" + height);\n    }\n\n    var xRadius = (width - 1) / 2;\n    var yRadius = (height - 1) / 2;\n    var windowMatrix = new PixelMatrix(width, height, this.colorProfile);\n\n    for (var yOffset = -yRadius; yOffset <= yRadius; yOffset++) {\n      for (var xOffset = -xRadius; xOffset <= xRadius; xOffset++) {\n        var x = center.x + xOffset;\n        var y = center.y + yOffset;\n        var point = {\n          x: x,\n          y: y\n        };\n        var pixel = this.contains(point) ? this.get(point) : EMPTY_PIXEL;\n        var pointInWindow = {\n          x: xOffset + xRadius,\n          y: yOffset + yRadius\n        };\n        windowMatrix.set(pointInWindow, pixel);\n      }\n    }\n\n    return windowMatrix;\n  };\n\n  PixelMatrix.prototype.contains = function (point) {\n    return point.x >= 0 && point.x < this.width && point.y >= 0 && point.y < this.height;\n  };\n\n  PixelMatrix.prototype.toImageData = function () {\n    return new ImageData(this.pixels, this.width, this.height);\n  };\n\n  PixelMatrix.prototype.putPixels = function (canvas) {\n    if (canvas.width !== this.width || canvas.height !== this.height) {\n      throw new Error(\"Expected canvas shape and PixelMatrix shape to be the same, but canvas shape was [\" + canvas.width + \", \" + canvas.height + \"] and PixelMatrix shape was \" + this.shape + \".\");\n    }\n\n    var context = canvas.getContext('2d');\n    context.putImageData(this.toImageData(), 0, 0);\n  };\n\n  PixelMatrix.prototype.getCenter = function () {\n    var x = Math.floor(this.width / 2);\n    var y = Math.floor(this.height / 2);\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  return PixelMatrix;\n}();\n\nvar _default = PixelMatrix;\nexport default _default;\n;\n\n(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n\n  var leaveModule = require('react-hot-loader').leaveModule;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(RGBA, \"RGBA\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(COLOR_PROFILES, \"COLOR_PROFILES\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(isEven, \"isEven\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(EMPTY_PIXEL, \"EMPTY_PIXEL\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(vonNeumannOffsets, \"vonNeumannOffsets\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(mooreOffsets, \"mooreOffsets\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(x, \"x\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(y, \"y\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(PixelMatrix, \"PixelMatrix\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  reactHotLoader.register(_default, \"default\", \"/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js\");\n  leaveModule(module);\n})();\n\n;",{"version":3,"sources":["/Users/noisemachines/dev/pixel-matrix/built/PixelMatrix.module.js"],"names":["RGBA","channels","COLOR_PROFILES","isEven","n","EMPTY_PIXEL","red","green","blue","alpha","vonNeumannOffsets","x","y","mooreOffsets","push","PixelMatrix","width","height","colorProfile","pixels","pixelsLength","undefined","Uint8ClampedArray","length","Error","fromCanvas","canvas","context","getContext","imageData","getImageData","data","Object","defineProperty","prototype","get","_pixelMatrix","pixelMatrix_1","Array","forEach","pixel","point","enumerable","configurable","contains","i","getIndex","channelOffset","channel","getRandomPoint","Math","round","random","getRandomPixel","randomPoint","getVonNeumannNeighboringPixels","getNeighboringPixels","getVonNeumannNeighboringPoints","getNeighbors","getMooreNeighboringPixels","getMooreNeighboringPoints","neighborhood","_this","map","neighbor","neighbors","offset","set","pixelMatrix","randomDitherFrom","newMatrix","samples","_loop_1","_","this_1","newPixel","p","darkeningFactor","fn","freeze","newPixelMatrix","normalizedMap","normalizedPoint","reduce","startingValue","total","getWindow","center","xRadius","yRadius","windowMatrix","yOffset","xOffset","pointInWindow","toImageData","ImageData","putPixels","shape","putImageData","getCenter","floor"],"mappings":";;;;;;AAAA,IAAIA,IAAI,GAAG;AACPC,EAAAA,QAAQ,EAAE;AADH,CAAX;AAGA,OAAO,IAAIC,cAAc,GAAG;AACxBF,EAAAA,IAAI,EAAEA;AADkB,CAArB;;AAGP,IAAIG,MAAM,GAAG,SAATA,MAAS,CAAUC,CAAV,EAAa;AAAE,SAAOA,CAAC,GAAG,CAAJ,KAAU,CAAjB;AAAqB,CAAjD;;AACA,IAAIC,WAAW,GAAG;AACdC,EAAAA,GAAG,EAAE,CADS;AAEdC,EAAAA,KAAK,EAAE,CAFO;AAGdC,EAAAA,IAAI,EAAE,CAHQ;AAIdC,EAAAA,KAAK,EAAE;AAJO,CAAlB;AAMA,OAAO,IAAIC,iBAAiB,GAAG,CAC3B;AAAEC,EAAAA,CAAC,EAAE,CAAC,CAAN;AAASC,EAAAA,CAAC,EAAE;AAAZ,CAD2B,EAE3B;AAAED,EAAAA,CAAC,EAAE,CAAL;AAAQC,EAAAA,CAAC,EAAE;AAAX,CAF2B,EAG3B;AAAED,EAAAA,CAAC,EAAE,CAAL;AAAQC,EAAAA,CAAC,EAAE,CAAC;AAAZ,CAH2B,EAI3B;AAAED,EAAAA,CAAC,EAAE,CAAL;AAAQC,EAAAA,CAAC,EAAE;AAAX,CAJ2B,CAAxB;AAMP,OAAO,IAAIC,YAAY,GAAG,EAAnB;;AACP,KAAK,IAAIF,CAAC,GAAG,CAAC,CAAd,EAAiBA,CAAC,IAAI,CAAtB,EAAyBA,CAAC,EAA1B,EAA8B;AAC1B,OAAK,IAAIC,CAAC,GAAG,CAAC,CAAd,EAAiBA,CAAC,IAAI,CAAtB,EAAyBA,CAAC,EAA1B,EAA8B;AAC1B,QAAID,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAArB,EAAwB;AACpB;AACH;;AACDC,IAAAA,YAAY,CAACC,IAAb,CAAkB;AAAEH,MAAAA,CAAC,EAAEA,CAAL;AAAQC,MAAAA,CAAC,EAAEA;AAAX,KAAlB;AACH;AACJ;;AACD,IAAIG,WAAW;AAAG;AAAe,YAAY;AACzC,WAASA,WAAT,CAAqBC,KAArB,EAA4BC,MAA5B,EAAoCC,YAApC,EAAkDC,MAAlD,EAA0D;AACtD,QAAID,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,MAAAA,YAAY,GAAGlB,IAAf;AAAsB;;AACrD,SAAKgB,KAAL,GAAaA,KAAb;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,QAAIE,YAAY,GAAGJ,KAAK,GAAGC,MAAR,GAAiBC,YAAY,CAACjB,QAAjD;;AACA,QAAIkB,MAAM,KAAKE,SAAf,EAA0B;AACtBF,MAAAA,MAAM,GAAG,IAAIG,iBAAJ,CAAsBF,YAAtB,CAAT;AACH,KAFD,MAGK;AACD,UAAIA,YAAY,KAAKD,MAAM,CAACI,MAA5B,EAAoC;AAChC,cAAM,IAAIC,KAAJ,CAAU,oCAAoCJ,YAApC,GAAmD,oDAAnD,GAA0GD,MAAM,CAACI,MAAjH,GAA0H,WAApI,CAAN;AACH;AACJ;;AACD,SAAKJ,MAAL,GAAcA,MAAd;AACH;;AACDJ,EAAAA,WAAW,CAACU,UAAZ,GAAyB,UAAUC,MAAV,EAAkB;AACvC,QAAIC,OAAO,GAAGD,MAAM,CAACE,UAAP,CAAkB,IAAlB,CAAd;AACA,QAAIC,SAAS,GAAGF,OAAO,CAACG,YAAR,CAAqB,CAArB,EAAwB,CAAxB,EAA2BJ,MAAM,CAACV,KAAlC,EAAyCU,MAAM,CAACT,MAAhD,CAAhB;AACA,WAAO,IAAIF,WAAJ,CAAgBW,MAAM,CAACV,KAAvB,EAA8BU,MAAM,CAACT,MAArC,EAA6Cf,cAAc,CAACF,IAA5D,EAAkE6B,SAAS,CAACE,IAA5E,CAAP;AACH,GAJD;;AAKAC,EAAAA,MAAM,CAACC,cAAP,CAAsBlB,WAAW,CAACmB,SAAlC,EAA6C,aAA7C,EAA4D;AACxDC,IAAAA,GAAG,EAAE,eAAY;AACb,UAAI,CAAC,KAAKC,YAAV,EAAwB;AACpB,YAAIC,aAAa,GAAG,IAAIC,KAAJ,CAAU,KAAKtB,KAAf,CAApB;AACA,aAAKuB,OAAL,CAAa,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AACjC,cAAI,CAACJ,aAAa,CAACI,KAAK,CAAC9B,CAAP,CAAlB,EACI0B,aAAa,CAACI,KAAK,CAAC9B,CAAP,CAAb,GAAyB,EAAzB;AACJ0B,UAAAA,aAAa,CAACI,KAAK,CAAC9B,CAAP,CAAb,CAAuB8B,KAAK,CAAC7B,CAA7B,IAAkC4B,KAAlC;AACH,SAJD;AAKA,aAAKJ,YAAL,GAAoBC,aAApB;AACH;;AACD,aAAO,KAAKD,YAAZ;AACH,KAZuD;AAaxDM,IAAAA,UAAU,EAAE,IAb4C;AAcxDC,IAAAA,YAAY,EAAE;AAd0C,GAA5D;AAgBAX,EAAAA,MAAM,CAACC,cAAP,CAAsBlB,WAAW,CAACmB,SAAlC,EAA6C,UAA7C,EAAyD;AACrDC,IAAAA,GAAG,EAAE,eAAY;AACb,aAAO,KAAKjB,YAAL,CAAkBjB,QAAzB;AACH,KAHoD;AAIrDyC,IAAAA,UAAU,EAAE,IAJyC;AAKrDC,IAAAA,YAAY,EAAE;AALuC,GAAzD;AAOAX,EAAAA,MAAM,CAACC,cAAP,CAAsBlB,WAAW,CAACmB,SAAlC,EAA6C,OAA7C,EAAsD;AAClDC,IAAAA,GAAG,EAAE,eAAY;AACb,aAAO,CAAC,KAAKnB,KAAN,EAAa,KAAKC,MAAlB,CAAP;AACH,KAHiD;AAIlDyB,IAAAA,UAAU,EAAE,IAJsC;AAKlDC,IAAAA,YAAY,EAAE;AALoC,GAAtD;AAOAX,EAAAA,MAAM,CAACC,cAAP,CAAsBlB,WAAW,CAACmB,SAAlC,EAA6C,aAA7C,EAA4D;AACxDC,IAAAA,GAAG,EAAE,eAAY;AACb,aAAO,KAAKnB,KAAL,GAAa,KAAKC,MAAzB;AACH,KAHuD;AAIxDyB,IAAAA,UAAU,EAAE,IAJ4C;AAKxDC,IAAAA,YAAY,EAAE;AAL0C,GAA5D;;AAOA5B,EAAAA,WAAW,CAACmB,SAAZ,CAAsBC,GAAtB,GAA4B,UAAUM,KAAV,EAAiB;AACzC,QAAI,CAAC,KAAKG,QAAL,CAAcH,KAAd,CAAL,EAA2B;AACvB,YAAM,IAAIjB,KAAJ,CAAU,iDAAiDiB,KAAjD,GAAyD,GAAnE,CAAN;AACH;;AACD,QAAII,CAAC,GAAG,KAAKC,QAAL,CAAcL,KAAd,CAAR;AACA,QAAIxC,QAAQ,GAAG,EAAf;;AACA,SAAK,IAAI8C,aAAa,GAAG,CAAzB,EAA4BA,aAAa,GAAG,KAAK7B,YAAL,CAAkBjB,QAA9D,EAAwE8C,aAAa,EAArF,EAAyF;AACrF,UAAIC,OAAO,GAAG,KAAK7B,MAAL,CAAY0B,CAAC,GAAGE,aAAhB,CAAd;AACA,UAAI,CAACC,OAAL,EACI,OAAO3C,WAAP;AACJJ,MAAAA,QAAQ,CAACa,IAAT,CAAckC,OAAd;AACH;;AACD,QAAI1C,GAAG,GAAGL,QAAQ,CAAC,CAAD,CAAlB;AAAA,QAAuBM,KAAK,GAAGN,QAAQ,CAAC,CAAD,CAAvC;AAAA,QAA4CO,IAAI,GAAGP,QAAQ,CAAC,CAAD,CAA3D;AAAA,QAAgEQ,KAAK,GAAGR,QAAQ,CAAC,CAAD,CAAhF;AACA,WAAO;AAAEK,MAAAA,GAAG,EAAEA,GAAP;AAAYC,MAAAA,KAAK,EAAEA,KAAnB;AAA0BC,MAAAA,IAAI,EAAEA,IAAhC;AAAsCC,MAAAA,KAAK,EAAEA;AAA7C,KAAP;AACH,GAdD;;AAeAM,EAAAA,WAAW,CAACmB,SAAZ,CAAsBe,cAAtB,GAAuC,YAAY;AAC/C,QAAItC,CAAC,GAAGuC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiB,KAAKpC,KAAL,GAAa,CAA9B,CAAX,CAAR;AACA,QAAIJ,CAAC,GAAGsC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiB,KAAKnC,MAAL,GAAc,CAA/B,CAAX,CAAR;AACA,WAAO;AAAEN,MAAAA,CAAC,EAAEA,CAAL;AAAQC,MAAAA,CAAC,EAAEA;AAAX,KAAP;AACH,GAJD;;AAKAG,EAAAA,WAAW,CAACmB,SAAZ,CAAsBmB,cAAtB,GAAuC,YAAY;AAC/C,QAAIC,WAAW,GAAG,KAAKL,cAAL,EAAlB;AACA,WAAO,KAAKd,GAAL,CAASmB,WAAT,CAAP;AACH,GAHD;;AAIAvC,EAAAA,WAAW,CAACmB,SAAZ,CAAsBqB,8BAAtB,GAAuD,UAAUd,KAAV,EAAiB;AACpE,WAAO,KAAKe,oBAAL,CAA0Bf,KAA1B,EAAiC/B,iBAAjC,CAAP;AACH,GAFD;;AAGAK,EAAAA,WAAW,CAACmB,SAAZ,CAAsBuB,8BAAtB,GAAuD,UAAUhB,KAAV,EAAiB;AACpE,WAAO,KAAKiB,YAAL,CAAkBjB,KAAlB,EAAyB/B,iBAAzB,CAAP;AACH,GAFD;;AAGAK,EAAAA,WAAW,CAACmB,SAAZ,CAAsByB,yBAAtB,GAAkD,UAAUlB,KAAV,EAAiB;AAC/D,WAAO,KAAKe,oBAAL,CAA0Bf,KAA1B,EAAiC5B,YAAjC,CAAP;AACH,GAFD;;AAGAE,EAAAA,WAAW,CAACmB,SAAZ,CAAsB0B,yBAAtB,GAAkD,UAAUnB,KAAV,EAAiB;AAC/D,WAAO,KAAKiB,YAAL,CAAkBjB,KAAlB,EAAyB5B,YAAzB,CAAP;AACH,GAFD;;AAGAE,EAAAA,WAAW,CAACmB,SAAZ,CAAsBsB,oBAAtB,GAA6C,UAAUf,KAAV,EAAiBoB,YAAjB,EAA+B;AACxE,QAAIC,KAAK,GAAG,IAAZ;;AACA,WAAO,KAAKJ,YAAL,CAAkBjB,KAAlB,EAAyBoB,YAAzB,EAAuCE,GAAvC,CAA2C,UAAUC,QAAV,EAAoB;AAAE,aAAOF,KAAK,CAAC3B,GAAN,CAAU6B,QAAV,CAAP;AAA6B,KAA9F,CAAP;AACH,GAHD;;AAIAjD,EAAAA,WAAW,CAACmB,SAAZ,CAAsBwB,YAAtB,GAAqC,UAAUjB,KAAV,EAAiBoB,YAAjB,EAA+B;AAChE,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAIG,SAAS,GAAG,EAAhB;AACAJ,IAAAA,YAAY,CAACtB,OAAb,CAAqB,UAAU2B,MAAV,EAAkB;AACnC,UAAIF,QAAQ,GAAG;AACXrD,QAAAA,CAAC,EAAE8B,KAAK,CAAC9B,CAAN,GAAUuD,MAAM,CAACvD,CADT;AAEXC,QAAAA,CAAC,EAAE6B,KAAK,CAAC7B,CAAN,GAAUsD,MAAM,CAACtD;AAFT,OAAf;;AAIA,UAAIkD,KAAK,CAAClB,QAAN,CAAeoB,QAAf,CAAJ,EAA8B;AAC1BC,QAAAA,SAAS,CAACnD,IAAV,CAAekD,QAAf;AACH;AACJ,KARD;AASA,WAAOC,SAAP;AACH,GAbD;;AAcAlD,EAAAA,WAAW,CAACmB,SAAZ,CAAsBiC,GAAtB,GAA4B,UAAU1B,KAAV,EAAiBD,KAAjB,EAAwB;AAChD,QAAIlC,GAAG,GAAGkC,KAAK,CAAClC,GAAhB;AAAA,QAAqBC,KAAK,GAAGiC,KAAK,CAACjC,KAAnC;AAAA,QAA0CC,IAAI,GAAGgC,KAAK,CAAChC,IAAvD;AAAA,QAA6DC,KAAK,GAAG+B,KAAK,CAAC/B,KAA3E;AACA,QAAIoC,CAAC,GAAG,KAAKC,QAAL,CAAcL,KAAd,CAAR;AACA,SAAKtB,MAAL,CAAY0B,CAAZ,IAAiBvC,GAAjB;AACA,SAAKa,MAAL,CAAY0B,CAAC,GAAG,CAAhB,IAAqBtC,KAArB;AACA,SAAKY,MAAL,CAAY0B,CAAC,GAAG,CAAhB,IAAqBrC,IAArB;AACA,SAAKW,MAAL,CAAY0B,CAAC,GAAG,CAAhB,IAAqBpC,KAArB;AACA,SAAK2D,WAAL,CAAiB3B,KAAK,CAAC9B,CAAvB,EAA0B8B,KAAK,CAAC7B,CAAhC,IAAqC4B,KAArC;AACH,GARD;;AASAzB,EAAAA,WAAW,CAACmB,SAAZ,CAAsBmC,gBAAtB,GAAyC,UAAUC,SAAV,EAAqBC,OAArB,EAA8B;AACnE,QAAIT,KAAK,GAAG,IAAZ;;AACA,QAAIS,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,MAAAA,OAAO,GAAG,IAAV;AAAiB;;AAC3C,QAAIC,OAAO,GAAG,SAAVA,OAAU,CAAUC,CAAV,EAAa;AACvB,UAAIhC,KAAK,GAAGiC,MAAM,CAACzB,cAAP,EAAZ;AACA,UAAI0B,QAAQ,GAAGL,SAAS,CAACnC,GAAV,CAAcM,KAAd,CAAf;AACA,UAAImC,CAAC,GAAGD,QAAR;AACA,UAAIE,eAAe,GAAG,CAAtB;;AACA,UAAI3B,IAAI,CAACE,MAAL,KAAgB,GAApB,EAAyB;AACrBwB,QAAAA,CAAC,GAAG;AACAtE,UAAAA,GAAG,EAAEqE,QAAQ,CAACrE,GAAT,GAAeuE,eADpB;AAEAtE,UAAAA,KAAK,EAAEoE,QAAQ,CAACpE,KAAT,GAAiBsE,eAFxB;AAGArE,UAAAA,IAAI,EAAEmE,QAAQ,CAACnE,IAAT,GAAgBqE,eAHtB;AAIApE,UAAAA,KAAK,EAAE;AAJP,SAAJ;AAMH;;AACDiE,MAAAA,MAAM,CAACjB,8BAAP,CAAsChB,KAAtC,EAA6CF,OAA7C,CAAqD,UAAUyB,QAAV,EAAoB;AACrEF,QAAAA,KAAK,CAACK,GAAN,CAAUH,QAAV,EAAoBY,CAApB;AACH,OAFD;AAGH,KAhBD;;AAiBA,QAAIF,MAAM,GAAG,IAAb;;AACA,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAApB,EAA6BE,CAAC,EAA9B,EAAkC;AAC9BD,MAAAA,OAAO,CAACC,CAAD,CAAP;AACH;AACJ,GAxBD;;AAyBA1D,EAAAA,WAAW,CAACmB,SAAZ,CAAsBY,QAAtB,GAAiC,UAAUL,KAAV,EAAiB;AAC9C,QAAI9B,CAAC,GAAG8B,KAAK,CAAC9B,CAAd;AAAA,QAAiBC,CAAC,GAAG6B,KAAK,CAAC7B,CAA3B;;AACA,QAAI,CAAC,KAAKgC,QAAL,CAAcH,KAAd,CAAL,EAA2B;AACvB,YAAM,IAAIjB,KAAJ,CAAU,mDAAmD,KAAKR,KAAxD,GAAgE,IAAhE,GAAuE,KAAKC,MAA5E,GAAqF,sBAArF,GAA8GN,CAA9G,GAAkH,IAAlH,GAAyHC,CAAzH,GAA6H,GAAvI,CAAN;AACH;;AACD,WAAOA,CAAC,IAAI,KAAKI,KAAL,GAAa,KAAKf,QAAtB,CAAD,GAAmCU,CAAC,GAAG,KAAKV,QAAnD;AACH,GAND;;AAOAc,EAAAA,WAAW,CAACmB,SAAZ,CAAsBK,OAAtB,GAAgC,UAAUuC,EAAV,EAAc;AAC1C,SAAK,IAAIlE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKK,MAAzB,EAAiCL,CAAC,EAAlC,EAAsC;AAClC,WAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKK,KAAzB,EAAgCL,CAAC,EAAjC,EAAqC;AACjC,YAAI8B,KAAK,GAAGT,MAAM,CAAC+C,MAAP,CAAc;AAAEpE,UAAAA,CAAC,EAAEA,CAAL;AAAQC,UAAAA,CAAC,EAAEA;AAAX,SAAd,CAAZ;AACA,YAAI4B,KAAK,GAAG,KAAKL,GAAL,CAASM,KAAT,CAAZ;AACAqC,QAAAA,EAAE,CAACtC,KAAD,EAAQC,KAAR,EAAe,IAAf,CAAF;AACH;AACJ;AACJ,GARD;;AASA1B,EAAAA,WAAW,CAACmB,SAAZ,CAAsB6B,GAAtB,GAA4B,UAAUe,EAAV,EAAc;AACtC,QAAIE,cAAc,GAAG,IAAIjE,WAAJ,CAAgB,KAAKC,KAArB,EAA4B,KAAKC,MAAjC,EAAyC,KAAKC,YAA9C,CAArB;AACA,SAAKqB,OAAL,CAAa,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB2B,WAAxB,EAAqC;AAC9C,UAAIO,QAAQ,GAAGG,EAAE,CAACtC,KAAD,EAAQC,KAAR,EAAe2B,WAAf,CAAjB;AACAY,MAAAA,cAAc,CAACb,GAAf,CAAmB1B,KAAnB,EAA0BkC,QAA1B;AACH,KAHD;AAIA,WAAOK,cAAP;AACH,GAPD;;AAQAjE,EAAAA,WAAW,CAACmB,SAAZ,CAAsB+C,aAAtB,GAAsC,UAAUH,EAAV,EAAc;AAChD,QAAIhB,KAAK,GAAG,IAAZ;;AACA,WAAO,KAAKC,GAAL,CAAS,UAAUvB,KAAV,EAAiBC,KAAjB,EAAwB2B,WAAxB,EAAqC;AACjD,UAAIc,eAAe,GAAG;AAClBvE,QAAAA,CAAC,EAAE8B,KAAK,CAAC9B,CAAN,GAAUmD,KAAK,CAAC9C,KADD;AAElBJ,QAAAA,CAAC,EAAE6B,KAAK,CAAC7B,CAAN,GAAUkD,KAAK,CAAC7C;AAFD,OAAtB;AAIA,aAAO6D,EAAE,CAACtC,KAAD,EAAQ0C,eAAR,EAAyBd,WAAzB,CAAT;AACH,KANM,CAAP;AAOH,GATD;;AAUArD,EAAAA,WAAW,CAACmB,SAAZ,CAAsBiD,MAAtB,GAA+B,UAAUL,EAAV,EAAcM,aAAd,EAA6B;AACxD,QAAIC,KAAK,GAAGD,aAAZ;AACA,SAAK7C,OAAL,CAAa,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AACjC4C,MAAAA,KAAK,GAAGP,EAAE,CAACO,KAAD,EAAQ7C,KAAR,EAAeC,KAAf,CAAV;AACH,KAFD;AAGA,WAAO4C,KAAP;AACH,GAND;;AAOAtE,EAAAA,WAAW,CAACmB,SAAZ,CAAsBoD,SAAtB,GAAkC,UAAUC,MAAV,EAAkBvE,KAAlB,EAAyBC,MAAzB,EAAiC;AAC/D,QAAId,MAAM,CAACa,KAAD,CAAV,EAAmB;AACf,YAAM,IAAIQ,KAAJ,CAAU,2CAA2CR,KAArD,CAAN;AACH;;AACD,QAAIb,MAAM,CAACc,MAAD,CAAV,EAAoB;AAChB,YAAM,IAAIO,KAAJ,CAAU,4CAA4CP,MAAtD,CAAN;AACH;;AACD,QAAIuE,OAAO,GAAG,CAACxE,KAAK,GAAG,CAAT,IAAc,CAA5B;AACA,QAAIyE,OAAO,GAAG,CAACxE,MAAM,GAAG,CAAV,IAAe,CAA7B;AACA,QAAIyE,YAAY,GAAG,IAAI3E,WAAJ,CAAgBC,KAAhB,EAAuBC,MAAvB,EAA+B,KAAKC,YAApC,CAAnB;;AACA,SAAK,IAAIyE,OAAO,GAAG,CAACF,OAApB,EAA6BE,OAAO,IAAIF,OAAxC,EAAiDE,OAAO,EAAxD,EAA4D;AACxD,WAAK,IAAIC,OAAO,GAAG,CAACJ,OAApB,EAA6BI,OAAO,IAAIJ,OAAxC,EAAiDI,OAAO,EAAxD,EAA4D;AACxD,YAAIjF,CAAC,GAAG4E,MAAM,CAAC5E,CAAP,GAAWiF,OAAnB;AACA,YAAIhF,CAAC,GAAG2E,MAAM,CAAC3E,CAAP,GAAW+E,OAAnB;AACA,YAAIlD,KAAK,GAAG;AAAE9B,UAAAA,CAAC,EAAEA,CAAL;AAAQC,UAAAA,CAAC,EAAEA;AAAX,SAAZ;AACA,YAAI4B,KAAK,GAAG,KAAKI,QAAL,CAAcH,KAAd,IAAuB,KAAKN,GAAL,CAASM,KAAT,CAAvB,GAAyCpC,WAArD;AACA,YAAIwF,aAAa,GAAG;AAAElF,UAAAA,CAAC,EAAEiF,OAAO,GAAGJ,OAAf;AAAwB5E,UAAAA,CAAC,EAAE+E,OAAO,GAAGF;AAArC,SAApB;AACAC,QAAAA,YAAY,CAACvB,GAAb,CAAiB0B,aAAjB,EAAgCrD,KAAhC;AACH;AACJ;;AACD,WAAOkD,YAAP;AACH,GArBD;;AAsBA3E,EAAAA,WAAW,CAACmB,SAAZ,CAAsBU,QAAtB,GAAiC,UAAUH,KAAV,EAAiB;AAC9C,WAAQA,KAAK,CAAC9B,CAAN,IAAW,CAAX,IACJ8B,KAAK,CAAC9B,CAAN,GAAU,KAAKK,KADX,IAEJyB,KAAK,CAAC7B,CAAN,IAAW,CAFP,IAGJ6B,KAAK,CAAC7B,CAAN,GAAU,KAAKK,MAHnB;AAIH,GALD;;AAMAF,EAAAA,WAAW,CAACmB,SAAZ,CAAsB4D,WAAtB,GAAoC,YAAY;AAC5C,WAAO,IAAIC,SAAJ,CAAc,KAAK5E,MAAnB,EAA2B,KAAKH,KAAhC,EAAuC,KAAKC,MAA5C,CAAP;AACH,GAFD;;AAGAF,EAAAA,WAAW,CAACmB,SAAZ,CAAsB8D,SAAtB,GAAkC,UAAUtE,MAAV,EAAkB;AAChD,QAAIA,MAAM,CAACV,KAAP,KAAiB,KAAKA,KAAtB,IAA+BU,MAAM,CAACT,MAAP,KAAkB,KAAKA,MAA1D,EAAkE;AAC9D,YAAM,IAAIO,KAAJ,CAAU,uFAAuFE,MAAM,CAACV,KAA9F,GAAsG,IAAtG,GAA6GU,MAAM,CAACT,MAApH,GAA6H,8BAA7H,GAA8J,KAAKgF,KAAnK,GAA2K,GAArL,CAAN;AACH;;AACD,QAAItE,OAAO,GAAGD,MAAM,CAACE,UAAP,CAAkB,IAAlB,CAAd;AACAD,IAAAA,OAAO,CAACuE,YAAR,CAAqB,KAAKJ,WAAL,EAArB,EAAyC,CAAzC,EAA4C,CAA5C;AACH,GAND;;AAOA/E,EAAAA,WAAW,CAACmB,SAAZ,CAAsBiE,SAAtB,GAAkC,YAAY;AAC1C,QAAIxF,CAAC,GAAGuC,IAAI,CAACkD,KAAL,CAAW,KAAKpF,KAAL,GAAa,CAAxB,CAAR;AACA,QAAIJ,CAAC,GAAGsC,IAAI,CAACkD,KAAL,CAAW,KAAKnF,MAAL,GAAc,CAAzB,CAAR;AACA,WAAO;AAAEN,MAAAA,CAAC,EAAEA,CAAL;AAAQC,MAAAA,CAAC,EAAEA;AAAX,KAAP;AACH,GAJD;;AAKA,SAAOG,WAAP;AACH,CAxOgC,EAAjC;;eAyOeA,W;AAAf;;;;;;;;;;;;0BArQIf,I;0BAGOE,c;0BAGPC,M;0BACAE,W;0BAMOK,iB;0BAMAG,Y;0BACFF,C;0BACIC,C;0BAOTG,W","sourcesContent":["var RGBA = {\n    channels: 4\n};\nexport var COLOR_PROFILES = {\n    RGBA: RGBA\n};\nvar isEven = function (n) { return n % 2 === 0; };\nvar EMPTY_PIXEL = {\n    red: 0,\n    green: 0,\n    blue: 0,\n    alpha: 0\n};\nexport var vonNeumannOffsets = [\n    { x: -1, y: 0 },\n    { x: 1, y: 0 },\n    { x: 0, y: -1 },\n    { x: 0, y: 1 }\n];\nexport var mooreOffsets = [];\nfor (var x = -1; x <= 1; x++) {\n    for (var y = -1; y <= 1; y++) {\n        if (x === 0 && y === 0) {\n            continue;\n        }\n        mooreOffsets.push({ x: x, y: y });\n    }\n}\nvar PixelMatrix = /** @class */ (function () {\n    function PixelMatrix(width, height, colorProfile, pixels) {\n        if (colorProfile === void 0) { colorProfile = RGBA; }\n        this.width = width;\n        this.height = height;\n        this.colorProfile = colorProfile;\n        var pixelsLength = width * height * colorProfile.channels;\n        if (pixels === undefined) {\n            pixels = new Uint8ClampedArray(pixelsLength);\n        }\n        else {\n            if (pixelsLength !== pixels.length) {\n                throw new Error(\"Expected pixels to have length \" + pixelsLength + \" (width * height * colorProfile.channels) but got \" + pixels.length + \" instead.\");\n            }\n        }\n        this.pixels = pixels;\n    }\n    PixelMatrix.fromCanvas = function (canvas) {\n        var context = canvas.getContext('2d');\n        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n        return new PixelMatrix(canvas.width, canvas.height, COLOR_PROFILES.RGBA, imageData.data);\n    };\n    Object.defineProperty(PixelMatrix.prototype, \"pixelMatrix\", {\n        get: function () {\n            if (!this._pixelMatrix) {\n                var pixelMatrix_1 = new Array(this.width);\n                this.forEach(function (pixel, point) {\n                    if (!pixelMatrix_1[point.x])\n                        pixelMatrix_1[point.x] = [];\n                    pixelMatrix_1[point.x][point.y] = pixel;\n                });\n                this._pixelMatrix = pixelMatrix_1;\n            }\n            return this._pixelMatrix;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PixelMatrix.prototype, \"channels\", {\n        get: function () {\n            return this.colorProfile.channels;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PixelMatrix.prototype, \"shape\", {\n        get: function () {\n            return [this.width, this.height];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PixelMatrix.prototype, \"countPixels\", {\n        get: function () {\n            return this.width * this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PixelMatrix.prototype.get = function (point) {\n        if (!this.contains(point)) {\n            throw new Error(\"This pixel matrix doesn't contain the point \" + point + \".\");\n        }\n        var i = this.getIndex(point);\n        var channels = [];\n        for (var channelOffset = 0; channelOffset < this.colorProfile.channels; channelOffset++) {\n            var channel = this.pixels[i + channelOffset];\n            if (!channel)\n                return EMPTY_PIXEL;\n            channels.push(channel);\n        }\n        var red = channels[0], green = channels[1], blue = channels[2], alpha = channels[3];\n        return { red: red, green: green, blue: blue, alpha: alpha };\n    };\n    PixelMatrix.prototype.getRandomPoint = function () {\n        var x = Math.round(Math.random() * (this.width - 1));\n        var y = Math.round(Math.random() * (this.height - 1));\n        return { x: x, y: y };\n    };\n    PixelMatrix.prototype.getRandomPixel = function () {\n        var randomPoint = this.getRandomPoint();\n        return this.get(randomPoint);\n    };\n    PixelMatrix.prototype.getVonNeumannNeighboringPixels = function (point) {\n        return this.getNeighboringPixels(point, vonNeumannOffsets);\n    };\n    PixelMatrix.prototype.getVonNeumannNeighboringPoints = function (point) {\n        return this.getNeighbors(point, vonNeumannOffsets);\n    };\n    PixelMatrix.prototype.getMooreNeighboringPixels = function (point) {\n        return this.getNeighboringPixels(point, mooreOffsets);\n    };\n    PixelMatrix.prototype.getMooreNeighboringPoints = function (point) {\n        return this.getNeighbors(point, mooreOffsets);\n    };\n    PixelMatrix.prototype.getNeighboringPixels = function (point, neighborhood) {\n        var _this = this;\n        return this.getNeighbors(point, neighborhood).map(function (neighbor) { return _this.get(neighbor); });\n    };\n    PixelMatrix.prototype.getNeighbors = function (point, neighborhood) {\n        var _this = this;\n        var neighbors = [];\n        neighborhood.forEach(function (offset) {\n            var neighbor = {\n                x: point.x + offset.x,\n                y: point.y + offset.y\n            };\n            if (_this.contains(neighbor)) {\n                neighbors.push(neighbor);\n            }\n        });\n        return neighbors;\n    };\n    PixelMatrix.prototype.set = function (point, pixel) {\n        var red = pixel.red, green = pixel.green, blue = pixel.blue, alpha = pixel.alpha;\n        var i = this.getIndex(point);\n        this.pixels[i] = red;\n        this.pixels[i + 1] = green;\n        this.pixels[i + 2] = blue;\n        this.pixels[i + 3] = alpha;\n        this.pixelMatrix[point.x][point.y] = pixel;\n    };\n    PixelMatrix.prototype.randomDitherFrom = function (newMatrix, samples) {\n        var _this = this;\n        if (samples === void 0) { samples = 1000; }\n        var _loop_1 = function (_) {\n            var point = this_1.getRandomPoint();\n            var newPixel = newMatrix.get(point);\n            var p = newPixel;\n            var darkeningFactor = 0;\n            if (Math.random() > 0.5) {\n                p = {\n                    red: newPixel.red - darkeningFactor,\n                    green: newPixel.green - darkeningFactor,\n                    blue: newPixel.blue - darkeningFactor,\n                    alpha: 255\n                };\n            }\n            this_1.getVonNeumannNeighboringPoints(point).forEach(function (neighbor) {\n                _this.set(neighbor, p);\n            });\n        };\n        var this_1 = this;\n        for (var _ = 0; _ < samples; _++) {\n            _loop_1(_);\n        }\n    };\n    PixelMatrix.prototype.getIndex = function (point) {\n        var x = point.x, y = point.y;\n        if (!this.contains(point)) {\n            throw new Error(\"Expected x and y to be less than or equal to (\" + this.width + \", \" + this.height + \") but was actually (\" + x + \", \" + y + \")\");\n        }\n        return y * (this.width * this.channels) + x * this.channels;\n    };\n    PixelMatrix.prototype.forEach = function (fn) {\n        for (var y = 0; y < this.height; y++) {\n            for (var x = 0; x < this.width; x++) {\n                var point = Object.freeze({ x: x, y: y });\n                var pixel = this.get(point);\n                fn(pixel, point, this);\n            }\n        }\n    };\n    PixelMatrix.prototype.map = function (fn) {\n        var newPixelMatrix = new PixelMatrix(this.width, this.height, this.colorProfile);\n        this.forEach(function (pixel, point, pixelMatrix) {\n            var newPixel = fn(pixel, point, pixelMatrix);\n            newPixelMatrix.set(point, newPixel);\n        });\n        return newPixelMatrix;\n    };\n    PixelMatrix.prototype.normalizedMap = function (fn) {\n        var _this = this;\n        return this.map(function (pixel, point, pixelMatrix) {\n            var normalizedPoint = {\n                x: point.x / _this.width,\n                y: point.y / _this.height\n            };\n            return fn(pixel, normalizedPoint, pixelMatrix);\n        });\n    };\n    PixelMatrix.prototype.reduce = function (fn, startingValue) {\n        var total = startingValue;\n        this.forEach(function (pixel, point) {\n            total = fn(total, pixel, point);\n        });\n        return total;\n    };\n    PixelMatrix.prototype.getWindow = function (center, width, height) {\n        if (isEven(width)) {\n            throw new Error(\"Expected an odd window width, but got \" + width);\n        }\n        if (isEven(height)) {\n            throw new Error(\"Expected an odd window height, but got \" + height);\n        }\n        var xRadius = (width - 1) / 2;\n        var yRadius = (height - 1) / 2;\n        var windowMatrix = new PixelMatrix(width, height, this.colorProfile);\n        for (var yOffset = -yRadius; yOffset <= yRadius; yOffset++) {\n            for (var xOffset = -xRadius; xOffset <= xRadius; xOffset++) {\n                var x = center.x + xOffset;\n                var y = center.y + yOffset;\n                var point = { x: x, y: y };\n                var pixel = this.contains(point) ? this.get(point) : EMPTY_PIXEL;\n                var pointInWindow = { x: xOffset + xRadius, y: yOffset + yRadius };\n                windowMatrix.set(pointInWindow, pixel);\n            }\n        }\n        return windowMatrix;\n    };\n    PixelMatrix.prototype.contains = function (point) {\n        return (point.x >= 0 &&\n            point.x < this.width &&\n            point.y >= 0 &&\n            point.y < this.height);\n    };\n    PixelMatrix.prototype.toImageData = function () {\n        return new ImageData(this.pixels, this.width, this.height);\n    };\n    PixelMatrix.prototype.putPixels = function (canvas) {\n        if (canvas.width !== this.width || canvas.height !== this.height) {\n            throw new Error(\"Expected canvas shape and PixelMatrix shape to be the same, but canvas shape was [\" + canvas.width + \", \" + canvas.height + \"] and PixelMatrix shape was \" + this.shape + \".\");\n        }\n        var context = canvas.getContext('2d');\n        context.putImageData(this.toImageData(), 0, 0);\n    };\n    PixelMatrix.prototype.getCenter = function () {\n        var x = Math.floor(this.width / 2);\n        var y = Math.floor(this.height / 2);\n        return { x: x, y: y };\n    };\n    return PixelMatrix;\n}());\nexport default PixelMatrix;\n"]}]}