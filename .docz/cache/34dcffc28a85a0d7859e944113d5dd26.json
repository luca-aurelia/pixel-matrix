{"remainingRequest":"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-loader/lib/index.js?{\"presets\":[[\"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-preset-docz/dist/index.js\",{\"flow\":true,\"typescript\":false,\"parseProps\":true}]],\"plugins\":[[\"/Users/noisemachines/dev/pixel-matrix/node_modules/docz-utils/lib/named-asset-import.js\",{\"loaderMap\":{\"svg\":{\"ReactComponent\":\"@svgr/webpack?-prettier,-svgo![path]\"}}}],\"/Users/noisemachines/dev/pixel-matrix/node_modules/react-hot-loader/babel.js\"],\"babelrc\":false,\"cacheCompression\":false,\"compact\":false}!/Users/noisemachines/dev/pixel-matrix/documentation/api.mdx","dependencies":[{"path":"/Users/noisemachines/dev/pixel-matrix/documentation/api.mdx","mtime":1547773457171},{"path":"/Users/noisemachines/dev/pixel-matrix/node_modules/cache-loader/dist/cjs.js","mtime":1547744876783},{"path":"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-loader/lib/index.js","mtime":1547744876677}],"contextDependencies":[],"result":["var _jsxFileName = \"/Users/noisemachines/dev/pixel-matrix/documentation/api.mdx\";\n\n(function () {\n  var enterModule = require('react-hot-loader').enterModule;\n\n  enterModule && enterModule(module);\n})();\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport React from 'react';\nimport { MDXTag } from '@mdx-js/tag';\nimport { Playground } from 'docz';\nimport PixelMatrix from '../built/PixelMatrix';\nimport exampleImageUrl from './kawase.small.jpg';\n\nvar MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    _classCallCheck(this, MDXContent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  _createClass(MDXContent, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n      return React.createElement(MDXTag, {\n        name: \"wrapper\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 16\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"h1\",\n        components: components,\n        props: {\n          \"id\": \"api\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 20\n        },\n        __self: this\n      }, \"API\"), React.createElement(MDXTag, {\n        name: \"h2\",\n        components: components,\n        props: {\n          \"id\": \"fromcanvas\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 21\n        },\n        __self: this\n      }, \"fromCanvas\"), React.createElement(MDXTag, {\n        name: \"blockquote\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 22\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        parentName: \"blockquote\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 23\n        },\n        __self: this\n      }, \"PixelMatrix.fromCanvas(htmlCanvasElement) // returns a new pixel matrix\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 25\n        },\n        __self: this\n      }, \"Creates a pixel matrix from a canvas, taking the canvas' width, height, and pixel data.\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 26\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-jsx\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 26\n        },\n        __self: this\n      }, \"import PixelMatrix from '@noisemachines/pixel-matrix'\\n\\n// Create a canvas\\nconst canvas = document.createElement('canvas')\\ncanvas.width = 100\\ncanvas.height = 100\\n\\n// Fill it with coral red.\\nconst context = canvas.getContext('2d')\\ncontext.fillStyle = 'rgb(222, 98, 98)'\\ncontext.fillRect(0, 0, 100, 100)\\n\\n// pixelMatrix will copy over the width, height, and\\n// pixel contents of canvas. So in this case, it\\n// will be 100 x 100, and filled with a lovely\\n// coral red.\\nconst pixelMatrix = PixelMatrix.fromCanvas(canvas)\\n\")), React.createElement(Playground, {\n        __codesandbox: \"undefined\",\n        __position: 0,\n        __code: '() => {\\n  const width = 1\\n  const height = 1\\n  const draw = canvas => {\\n    // Make sure we have a canvas to draw on.\\n    if (!canvas) return\\n\\n    // Initialize a new pixel matrix.\\n    const pixelMatrix = new PixelMatrix(width, height)\\n\\n    // Points are just objects.\\n    const point = { x: 0, y: 0 }\\n\\n    // So are colors.\\n    const color = {\\n      red: 222,\\n      green: 98,\\n      blue: 98,\\n      alpha: 255,\\n    }\\n\\n    // Set (0, 0) to a pleasant coral.\\n    pixelMatrix.set(point, color)\\n\\n    // Render the current contents of the pixel matrix to the canvas.\\n    pixelMatrix.putPixels(canvas)\\n  }\\n\\n  return (\\n    <canvas\\n      width={width}\\n      height={height}\\n      style={{ width: \\'20%\\', height: \\'20%\\', imageRendering: \\'pixelated\\' }}\\n      ref={draw}\\n    />\\n  )\\n}',\n        __scope: {\n          props: this ? this.props : props,\n          PixelMatrix: PixelMatrix,\n          exampleImageUrl: exampleImageUrl\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 44\n        },\n        __self: this\n      }, function () {\n        var width = 1;\n        var height = 1;\n\n        var draw = function draw(canvas) {\n          // Make sure we have a canvas to draw on.\n          if (!canvas) return; // Initialize a new pixel matrix.\n\n          var pixelMatrix = new PixelMatrix(width, height); // Points are just objects.\n\n          var point = {\n            x: 0,\n            y: 0 // So are colors.\n\n          };\n          var color = {\n            red: 222,\n            green: 98,\n            blue: 98,\n            alpha: 255 // Set (0, 0) to a pleasant coral.\n\n          };\n          pixelMatrix.set(point, color); // Render the current contents of the pixel matrix to the canvas.\n\n          pixelMatrix.putPixels(canvas);\n        };\n\n        return React.createElement(\"canvas\", {\n          width: width,\n          height: height,\n          style: {\n            width: '20%',\n            height: '20%',\n            imageRendering: 'pixelated'\n          },\n          ref: draw,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 73\n          },\n          __self: this\n        });\n      }), React.createElement(MDXTag, {\n        name: \"h2\",\n        components: components,\n        props: {\n          \"id\": \"drawing-a-gradient\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 79\n        },\n        __self: this\n      }, \"Drawing a gradient\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 80\n        },\n        __self: this\n      }, \"For more complex work, Pixel Matrix also offers functional building blocks like \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 80\n        },\n        __self: this\n      }, \"forEach\"), \", \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 80\n        },\n        __self: this\n      }, \"map\"), \", and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 80\n        },\n        __self: this\n      }, \"reduce\"), \".\"), React.createElement(Playground, {\n        __codesandbox: \"undefined\",\n        __position: 1,\n        __code: '() => {\\n  // Start the gradient with a pleasant coral red.\\n  const startColor = {\\n    red: 222,\\n    green: 98,\\n    blue: 98,\\n    alpha: 255,\\n  }\\n\\n  // End it with a warm, citrus-y sunset.\\n  const endColor = {\\n    red: 255,\\n    green: 184,\\n    blue: 140,\\n    alpha: 255,\\n  }\\n  // A helper function for gradually transitioning\\n  // between two numbers. When progress is 0\\n  // it returns the starting number, and when progress is 1\\n  // it returns the ending number. When progress is 0.5,\\n  // it returns the number halfway between the two.\\n  const lerp = (start, end, progress) => {\\n    const distance = end - start\\n    const interpolated = start + distance * progress\\n    return Math.round(interpolated)\\n  }\\n\\n  // Applies a linear interpolation to each channel of a color.\\n  const lerpColor = (start, end, progress) => {\\n    return {\\n      red: lerp(start.red, end.red, progress),\\n      green: lerp(start.green, end.green, progress),\\n      blue: lerp(start.blue, end.blue, progress),\\n      alpha: lerp(start.alpha, end.alpha, progress),\\n    }\\n  }\\n\\n  const width = 10\\n  const height = 1\\n\\n  const draw = canvas => {\\n    // Wait until we have a canvas to draw on.\\n    if (!canvas) return\\n\\n    const pixelMatrix = new PixelMatrix(width, height)\\n\\n    // .map transforms each pixel by running it through\\n    // the supplied callback. The new pixel values are\\n    // used to populate a new pixel matrix instance.\\n    const gradient = pixelMatrix.map((currentPixel, currentPoint) => {\\n      const progress = currentPoint.x / width\\n\\n      // Use lerp (\\\"linear interpolation\\\") to transition\\n      // gradually between our start color and end color.\\n      const newPixel = lerpColor(startColor, endColor, progress)\\n      return newPixel\\n    })\\n    gradient.putPixels(canvas)\\n  }\\n\\n  return (\\n    <canvas\\n      width={width}\\n      height={height}\\n      style={{ width: \\'100%\\', height: \\'20%\\', imageRendering: \\'pixelated\\' }}\\n      ref={draw}\\n    />\\n  )\\n}',\n        __scope: {\n          props: this ? this.props : props,\n          PixelMatrix: PixelMatrix,\n          exampleImageUrl: exampleImageUrl\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 81\n        },\n        __self: this\n      }, function () {\n        // Start the gradient with a pleasant coral red.\n        var startColor = {\n          red: 222,\n          green: 98,\n          blue: 98,\n          alpha: 255 // End it with a warm, citrus-y sunset.\n\n        };\n        var endColor = {\n          red: 255,\n          green: 184,\n          blue: 140,\n          alpha: 255 // A helper function for gradually transitioning\n          // between two numbers. When progress is 0\n          // it returns the starting number, and when progress is 1\n          // it returns the ending number. When progress is 0.5,\n          // it returns the number halfway between the two.\n\n        };\n\n        var lerp = function lerp(start, end, progress) {\n          var distance = end - start;\n          var interpolated = start + distance * progress;\n          return Math.round(interpolated);\n        }; // Applies a linear interpolation to each channel of a color.\n\n\n        var lerpColor = function lerpColor(start, end, progress) {\n          return {\n            red: lerp(start.red, end.red, progress),\n            green: lerp(start.green, end.green, progress),\n            blue: lerp(start.blue, end.blue, progress),\n            alpha: lerp(start.alpha, end.alpha, progress)\n          };\n        };\n\n        var width = 10;\n        var height = 1;\n\n        var draw = function draw(canvas) {\n          // Wait until we have a canvas to draw on.\n          if (!canvas) return;\n          var pixelMatrix = new PixelMatrix(width, height); // .map transforms each pixel by running it through\n          // the supplied callback. The new pixel values are\n          // used to populate a new pixel matrix instance.\n\n          var gradient = pixelMatrix.map(function (currentPixel, currentPoint) {\n            var progress = currentPoint.x / width; // Use lerp (\"linear interpolation\") to transition\n            // gradually between our start color and end color.\n\n            var newPixel = lerpColor(startColor, endColor, progress);\n            return newPixel;\n          });\n          gradient.putPixels(canvas);\n        };\n\n        return React.createElement(\"canvas\", {\n          width: width,\n          height: height,\n          style: {\n            width: '100%',\n            height: '20%',\n            imageRendering: 'pixelated'\n          },\n          ref: draw,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 142\n          },\n          __self: this\n        });\n      }), React.createElement(MDXTag, {\n        name: \"h2\",\n        components: components,\n        props: {\n          \"id\": \"load-an-image\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 145\n        },\n        __self: this\n      }, \"Load an image\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 146\n        },\n        __self: this\n      }, \"Pixel Matrix can load and interact with images by using an intermediate \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 146\n        },\n        __self: this\n      }, \"canvas\"), \" element.\"), React.createElement(Playground, {\n        __codesandbox: \"undefined\",\n        __position: 2,\n        __code: '() => {\\n  const draw = (image, canvas) => {\\n    // Pixel Matrix can\\'t load data from images directly,\\n    // so we have to create an intermediate canvas element.\\n    const imageCanvas = document.createElement(\\'canvas\\')\\n    imageCanvas.width = image.width\\n    imageCanvas.height = image.height\\n    // Draw the image to the intermediate canvas.\\n    const context = imageCanvas.getContext(\\'2d\\')\\n    context.drawImage(image, 0, 0)\\n\\n    // Instantiate a PixelMatrix from the canvas.\\n    // This will copy the width, height, and pixels\\n    // of the canvas into the pixel matrix.\\n    const pixelMatrix = PixelMatrix.fromCanvas(imageCanvas)\\n\\n    // Set our original canvas element to the same size as the image.\\n    canvas.width = image.width\\n    canvas.height = image.height\\n\\n    // Draw the image to our original canvas using pixel matrix.\\n    pixelMatrix.putPixels(canvas)\\n  }\\n\\n  const loadImage = canvas => {\\n    // Wait until we have a canvas to draw on.\\n    if (!canvas) return\\n\\n    // Create a new image element.\\n    const image = new Image()\\n\\n    // When the image loads, resolve the promise\\n    const onLoad = () => {\\n      draw(image, canvas)\\n    }\\n\\n    image.addEventListener(\\'load\\', onLoad, false)\\n\\n    // Start loading the image\\n    image.src = exampleImageUrl\\n  }\\n  return (\\n    <canvas\\n      style={{ width: \\'50%\\', height: \\'50%\\', imageRendering: \\'pixelated\\' }}\\n      ref={loadImage}\\n    />\\n  )\\n}',\n        __scope: {\n          props: this ? this.props : props,\n          PixelMatrix: PixelMatrix,\n          exampleImageUrl: exampleImageUrl\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 147\n        },\n        __self: this\n      }, function () {\n        var draw = function draw(image, canvas) {\n          // Pixel Matrix can't load data from images directly,\n          // so we have to create an intermediate canvas element.\n          var imageCanvas = document.createElement('canvas');\n          imageCanvas.width = image.width;\n          imageCanvas.height = image.height; // Draw the image to the intermediate canvas.\n\n          var context = imageCanvas.getContext('2d');\n          context.drawImage(image, 0, 0); // Instantiate a PixelMatrix from the canvas.\n          // This will copy the width, height, and pixels\n          // of the canvas into the pixel matrix.\n\n          var pixelMatrix = PixelMatrix.fromCanvas(imageCanvas); // Set our original canvas element to the same size as the image.\n\n          canvas.width = image.width;\n          canvas.height = image.height; // Draw the image to our original canvas using pixel matrix.\n\n          pixelMatrix.putPixels(canvas);\n        };\n\n        var loadImage = function loadImage(canvas) {\n          // Wait until we have a canvas to draw on.\n          if (!canvas) return; // Create a new image element.\n\n          var image = new Image(); // When the image loads, resolve the promise\n\n          var onLoad = function onLoad() {\n            draw(image, canvas);\n          };\n\n          image.addEventListener('load', onLoad, false); // Start loading the image\n\n          image.src = exampleImageUrl;\n        };\n\n        return React.createElement(\"canvas\", {\n          style: {\n            width: '50%',\n            height: '50%',\n            imageRendering: 'pixelated'\n          },\n          ref: loadImage,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 189\n          },\n          __self: this\n        });\n      }), React.createElement(MDXTag, {\n        name: \"h2\",\n        components: components,\n        props: {\n          \"id\": \"animation-sampling-an-images-color-distribution\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 192\n        },\n        __self: this\n      }, \"Animation: Sampling an image's color distribution\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 193\n        },\n        __self: this\n      }, \"Pixel Matrix makes it easy to remix and algorithmically modify images. For example, here's how to create a new image by randomly sampling the colors of another image.\"), React.createElement(Playground, {\n        __codesandbox: \"undefined\",\n        __position: 3,\n        __code: '() => {\\n  const width = 25\\n  const height = 25\\n\\n  const draw = (colorPaletteImage, canvas) => {\\n    // Pixel Matrix can\\'t load data from images directly,\\n    // so we have to create an intermediate canvas element.\\n    const colorPaletteCanvas = document.createElement(\\'canvas\\')\\n    colorPaletteCanvas.width = colorPaletteImage.width\\n    colorPaletteCanvas.height = colorPaletteImage.height\\n    // Draw the image to the intermediate canvas.\\n    const context = colorPaletteCanvas.getContext(\\'2d\\')\\n    context.drawImage(colorPaletteImage, 0, 0)\\n\\n    // Instantiate a PixelMatrix from the canvas.\\n    // This will copy the width, height, and pixels\\n    // of the canvas into the pixel matrix.\\n    // This pixel matrix will store our color palette.\\n    const colorPalette = PixelMatrix.fromCanvas(colorPaletteCanvas)\\n\\n    // Create a new pixel matrix, then map its empty pixels to\\n    // randomly chosen pixels from our color palette.\\n    const pixelMatrix = new PixelMatrix(width, height).map(() =>\\n      colorPalette.getRandomPixel(),\\n    )\\n\\n    // Draw the image to our canvas using pixel matrix.\\n    pixelMatrix.putPixels(canvas)\\n\\n    // Create an animation loop that paints a random pixel with\\n    // a random color from our color palette every frame.\\n    const animate = () => {\\n      // Get a random point in our pixel matrix.\\n      const point = pixelMatrix.getRandomPoint()\\n\\n      // Get a random color from our color palette.\\n      const pixel = colorPalette.getRandomPixel()\\n\\n      // Set the random point to the random color.\\n      pixelMatrix.set(point, pixel)\\n\\n      // Draw to the canvas.\\n      pixelMatrix.putPixels(canvas)\\n\\n      // Ask the browser to call this function again.\\n      window.requestAnimationFrame(animate)\\n    }\\n\\n    // Kick off the animation loop.\\n    animate()\\n  }\\n\\n  const loadImage = canvas => {\\n    // Wait until we have a canvas to draw on.\\n    if (!canvas) return\\n\\n    // Create a new image element.\\n    const image = new Image()\\n\\n    // When the image loads, resolve the promise\\n    const onLoad = () => {\\n      draw(image, canvas)\\n    }\\n\\n    image.addEventListener(\\'load\\', onLoad, false)\\n\\n    // Start loading the image\\n    image.src = exampleImageUrl\\n  }\\n  return (\\n    <canvas\\n      width={width}\\n      height={height}\\n      style={{ width: \\'50%\\', height: \\'50%\\', imageRendering: \\'pixelated\\' }}\\n      ref={loadImage}\\n    />\\n  )\\n}',\n        __scope: {\n          props: this ? this.props : props,\n          PixelMatrix: PixelMatrix,\n          exampleImageUrl: exampleImageUrl\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 194\n        },\n        __self: this\n      }, function () {\n        var width = 25;\n        var height = 25;\n\n        var draw = function draw(colorPaletteImage, canvas) {\n          // Pixel Matrix can't load data from images directly,\n          // so we have to create an intermediate canvas element.\n          var colorPaletteCanvas = document.createElement('canvas');\n          colorPaletteCanvas.width = colorPaletteImage.width;\n          colorPaletteCanvas.height = colorPaletteImage.height; // Draw the image to the intermediate canvas.\n\n          var context = colorPaletteCanvas.getContext('2d');\n          context.drawImage(colorPaletteImage, 0, 0); // Instantiate a PixelMatrix from the canvas.\n          // This will copy the width, height, and pixels\n          // of the canvas into the pixel matrix.\n          // This pixel matrix will store our color palette.\n\n          var colorPalette = PixelMatrix.fromCanvas(colorPaletteCanvas); // Create a new pixel matrix, then map its empty pixels to\n          // randomly chosen pixels from our color palette.\n\n          var pixelMatrix = new PixelMatrix(width, height).map(function () {\n            return colorPalette.getRandomPixel();\n          }); // Draw the image to our canvas using pixel matrix.\n\n          pixelMatrix.putPixels(canvas); // Create an animation loop that paints a random pixel with\n          // a random color from our color palette every frame.\n\n          var animate = function animate() {\n            // Get a random point in our pixel matrix.\n            var point = pixelMatrix.getRandomPoint(); // Get a random color from our color palette.\n\n            var pixel = colorPalette.getRandomPixel(); // Set the random point to the random color.\n\n            pixelMatrix.set(point, pixel); // Draw to the canvas.\n\n            pixelMatrix.putPixels(canvas); // Ask the browser to call this function again.\n\n            window.requestAnimationFrame(animate);\n          }; // Kick off the animation loop.\n\n\n          animate();\n        };\n\n        var loadImage = function loadImage(canvas) {\n          // Wait until we have a canvas to draw on.\n          if (!canvas) return; // Create a new image element.\n\n          var image = new Image(); // When the image loads, resolve the promise\n\n          var onLoad = function onLoad() {\n            draw(image, canvas);\n          };\n\n          image.addEventListener('load', onLoad, false); // Start loading the image\n\n          image.src = exampleImageUrl;\n        };\n\n        return React.createElement(\"canvas\", {\n          width: width,\n          height: height,\n          style: {\n            width: '50%',\n            height: '50%',\n            imageRendering: 'pixelated'\n          },\n          ref: loadImage,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 262\n          },\n          __self: this\n        });\n      }));\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return MDXContent;\n}(React.Component);\n\nexport { MDXContent as default };\n;\n\n(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n\n  var leaveModule = require('react-hot-loader').leaveModule;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(MDXContent, \"MDXContent\", \"/Users/noisemachines/dev/pixel-matrix/documentation/api.mdx\");\n  leaveModule(module);\n})();\n\n;\nMDXContent.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [],\n  \"displayName\": \"MDXContent\"\n};",{"version":3,"sources":["/Users/noisemachines/dev/pixel-matrix/documentation/api.mdx"],"names":["React","MDXTag","Playground","PixelMatrix","exampleImageUrl","MDXContent","props","layout","components","width","height","draw","canvas","pixelMatrix","point","x","y","color","red","green","blue","alpha","set","putPixels","imageRendering","startColor","endColor","lerp","start","end","progress","distance","interpolated","Math","round","lerpColor","gradient","map","currentPixel","currentPoint","newPixel","image","imageCanvas","document","createElement","context","getContext","drawImage","fromCanvas","loadImage","Image","onLoad","addEventListener","src","colorPaletteImage","colorPaletteCanvas","colorPalette","getRandomPixel","animate","getRandomPoint","pixel","window","requestAnimationFrame","Component"],"mappings":"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","sourcesContent":["\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  import { Playground } from 'docz'\nimport PixelMatrix from '../built/PixelMatrix'\nimport exampleImageUrl from './kawase.small.jpg'\n\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}>\n<MDXTag name=\"h1\" components={components} props={{\"id\":\"api\"}}>{`API`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"fromcanvas\"}}>{`fromCanvas`}</MDXTag>\n<MDXTag name=\"blockquote\" components={components}>\n<MDXTag name=\"p\" components={components} parentName=\"blockquote\">{`PixelMatrix.fromCanvas(htmlCanvasElement) // returns a new pixel matrix`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`Creates a pixel matrix from a canvas, taking the canvas' width, height, and pixel data.`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-jsx\"}}>{`import PixelMatrix from '@noisemachines/pixel-matrix'\n\n// Create a canvas\nconst canvas = document.createElement('canvas')\ncanvas.width = 100\ncanvas.height = 100\n\n// Fill it with coral red.\nconst context = canvas.getContext('2d')\ncontext.fillStyle = 'rgb(222, 98, 98)'\ncontext.fillRect(0, 0, 100, 100)\n\n// pixelMatrix will copy over the width, height, and\n// pixel contents of canvas. So in this case, it\n// will be 100 x 100, and filled with a lovely\n// coral red.\nconst pixelMatrix = PixelMatrix.fromCanvas(canvas)\n`}</MDXTag></MDXTag>\n<Playground __codesandbox={`undefined`} __position={0} __code={'() => {\\n  const width = 1\\n  const height = 1\\n  const draw = canvas => {\\n    // Make sure we have a canvas to draw on.\\n    if (!canvas) return\\n\\n    // Initialize a new pixel matrix.\\n    const pixelMatrix = new PixelMatrix(width, height)\\n\\n    // Points are just objects.\\n    const point = { x: 0, y: 0 }\\n\\n    // So are colors.\\n    const color = {\\n      red: 222,\\n      green: 98,\\n      blue: 98,\\n      alpha: 255,\\n    }\\n\\n    // Set (0, 0) to a pleasant coral.\\n    pixelMatrix.set(point, color)\\n\\n    // Render the current contents of the pixel matrix to the canvas.\\n    pixelMatrix.putPixels(canvas)\\n  }\\n\\n  return (\\n    <canvas\\n      width={width}\\n      height={height}\\n      style={{ width: \\'20%\\', height: \\'20%\\', imageRendering: \\'pixelated\\' }}\\n      ref={draw}\\n    />\\n  )\\n}'} __scope={{props: this ? this.props : props,PixelMatrix,exampleImageUrl}}>\n  {() => {\n    const width = 1\n    const height = 1\nconst draw = canvas => {\n  // Make sure we have a canvas to draw on.\n  if (!canvas) return\n\n  // Initialize a new pixel matrix.\n  const pixelMatrix = new PixelMatrix(width, height)\n\n  // Points are just objects.\n  const point = { x: 0, y: 0 }\n\n  // So are colors.\n  const color = {\n    red: 222,\n    green: 98,\n    blue: 98,\n    alpha: 255\n  }\n\n  // Set (0, 0) to a pleasant coral.\n  pixelMatrix.set(point, color)\n\n  // Render the current contents of the pixel matrix to the canvas.\n  pixelMatrix.putPixels(canvas)\n}\n\nreturn <canvas\n  width={width}\n  height={height}\n  style={{ width: '20%', height: '20%', imageRendering: 'pixelated' }} ref={draw} />\n}}\n</Playground>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"drawing-a-gradient\"}}>{`Drawing a gradient`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`For more complex work, Pixel Matrix also offers functional building blocks like `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`forEach`}</MDXTag>{`, `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`map`}</MDXTag>{`, and `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`reduce`}</MDXTag>{`.`}</MDXTag>\n<Playground __codesandbox={`undefined`} __position={1} __code={'() => {\\n  // Start the gradient with a pleasant coral red.\\n  const startColor = {\\n    red: 222,\\n    green: 98,\\n    blue: 98,\\n    alpha: 255,\\n  }\\n\\n  // End it with a warm, citrus-y sunset.\\n  const endColor = {\\n    red: 255,\\n    green: 184,\\n    blue: 140,\\n    alpha: 255,\\n  }\\n  // A helper function for gradually transitioning\\n  // between two numbers. When progress is 0\\n  // it returns the starting number, and when progress is 1\\n  // it returns the ending number. When progress is 0.5,\\n  // it returns the number halfway between the two.\\n  const lerp = (start, end, progress) => {\\n    const distance = end - start\\n    const interpolated = start + distance * progress\\n    return Math.round(interpolated)\\n  }\\n\\n  // Applies a linear interpolation to each channel of a color.\\n  const lerpColor = (start, end, progress) => {\\n    return {\\n      red: lerp(start.red, end.red, progress),\\n      green: lerp(start.green, end.green, progress),\\n      blue: lerp(start.blue, end.blue, progress),\\n      alpha: lerp(start.alpha, end.alpha, progress),\\n    }\\n  }\\n\\n  const width = 10\\n  const height = 1\\n\\n  const draw = canvas => {\\n    // Wait until we have a canvas to draw on.\\n    if (!canvas) return\\n\\n    const pixelMatrix = new PixelMatrix(width, height)\\n\\n    // .map transforms each pixel by running it through\\n    // the supplied callback. The new pixel values are\\n    // used to populate a new pixel matrix instance.\\n    const gradient = pixelMatrix.map((currentPixel, currentPoint) => {\\n      const progress = currentPoint.x / width\\n\\n      // Use lerp (\\\"linear interpolation\\\") to transition\\n      // gradually between our start color and end color.\\n      const newPixel = lerpColor(startColor, endColor, progress)\\n      return newPixel\\n    })\\n    gradient.putPixels(canvas)\\n  }\\n\\n  return (\\n    <canvas\\n      width={width}\\n      height={height}\\n      style={{ width: \\'100%\\', height: \\'20%\\', imageRendering: \\'pixelated\\' }}\\n      ref={draw}\\n    />\\n  )\\n}'} __scope={{props: this ? this.props : props,PixelMatrix,exampleImageUrl}}>\n  {() => {\n    // Start the gradient with a pleasant coral red.\n    const startColor = {\n      red: 222,\n      green: 98,\n      blue: 98,\n      alpha: 255\n    }\n    \n    // End it with a warm, citrus-y sunset.\n    const endColor = {\n      red: 255,\n      green: 184,\n      blue: 140,\n      alpha: 255\n    }\n// A helper function for gradually transitioning\n// between two numbers. When progress is 0\n// it returns the starting number, and when progress is 1\n// it returns the ending number. When progress is 0.5,\n// it returns the number halfway between the two.\nconst lerp = (start, end, progress) => {\n  const distance = end - start\n  const interpolated = start + (distance * progress)\n  return Math.round(interpolated)\n}\n\n// Applies a linear interpolation to each channel of a color.\nconst lerpColor = (start, end, progress) => {\n  return {\n    red: lerp(start.red, end.red, progress),\n    green: lerp(start.green, end.green, progress),\n    blue: lerp(start.blue, end.blue, progress),\n    alpha: lerp(start.alpha, end.alpha, progress)\n  }\n}\n\nconst width = 10\nconst height = 1\n\nconst draw = canvas => {\n  // Wait until we have a canvas to draw on.\n  if (!canvas) return\n\n  const pixelMatrix = new PixelMatrix(width, height)\n\n  // .map transforms each pixel by running it through\n  // the supplied callback. The new pixel values are\n  // used to populate a new pixel matrix instance.\n  const gradient = pixelMatrix.map((currentPixel, currentPoint) => {\n    const progress = currentPoint.x / width\n\n    // Use lerp (\"linear interpolation\") to transition\n    // gradually between our start color and end color.\n    const newPixel = lerpColor(startColor, endColor, progress)\n    return newPixel\n  })\n  gradient.putPixels(canvas)\n}\n\nreturn <canvas width={width} height={height} style={{ width: '100%', height: '20%', imageRendering: 'pixelated' }} ref={draw} />\n}}\n</Playground>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"load-an-image\"}}>{`Load an image`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`Pixel Matrix can load and interact with images by using an intermediate `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`canvas`}</MDXTag>{` element.`}</MDXTag>\n<Playground __codesandbox={`undefined`} __position={2} __code={'() => {\\n  const draw = (image, canvas) => {\\n    // Pixel Matrix can\\'t load data from images directly,\\n    // so we have to create an intermediate canvas element.\\n    const imageCanvas = document.createElement(\\'canvas\\')\\n    imageCanvas.width = image.width\\n    imageCanvas.height = image.height\\n    // Draw the image to the intermediate canvas.\\n    const context = imageCanvas.getContext(\\'2d\\')\\n    context.drawImage(image, 0, 0)\\n\\n    // Instantiate a PixelMatrix from the canvas.\\n    // This will copy the width, height, and pixels\\n    // of the canvas into the pixel matrix.\\n    const pixelMatrix = PixelMatrix.fromCanvas(imageCanvas)\\n\\n    // Set our original canvas element to the same size as the image.\\n    canvas.width = image.width\\n    canvas.height = image.height\\n\\n    // Draw the image to our original canvas using pixel matrix.\\n    pixelMatrix.putPixels(canvas)\\n  }\\n\\n  const loadImage = canvas => {\\n    // Wait until we have a canvas to draw on.\\n    if (!canvas) return\\n\\n    // Create a new image element.\\n    const image = new Image()\\n\\n    // When the image loads, resolve the promise\\n    const onLoad = () => {\\n      draw(image, canvas)\\n    }\\n\\n    image.addEventListener(\\'load\\', onLoad, false)\\n\\n    // Start loading the image\\n    image.src = exampleImageUrl\\n  }\\n  return (\\n    <canvas\\n      style={{ width: \\'50%\\', height: \\'50%\\', imageRendering: \\'pixelated\\' }}\\n      ref={loadImage}\\n    />\\n  )\\n}'} __scope={{props: this ? this.props : props,PixelMatrix,exampleImageUrl}}>\n  {() => {\n    const draw = (image, canvas) => {\n      // Pixel Matrix can't load data from images directly,\n      // so we have to create an intermediate canvas element.\n      const imageCanvas = document.createElement('canvas')\n      imageCanvas.width = image.width\n      imageCanvas.height = image.height\n  // Draw the image to the intermediate canvas.\n  const context = imageCanvas.getContext('2d')\n  context.drawImage(image, 0, 0)\n\n  // Instantiate a PixelMatrix from the canvas.\n  // This will copy the width, height, and pixels\n  // of the canvas into the pixel matrix.\n  const pixelMatrix = PixelMatrix.fromCanvas(imageCanvas)\n\n  // Set our original canvas element to the same size as the image.\n  canvas.width = image.width\n  canvas.height = image.height\n\n  // Draw the image to our original canvas using pixel matrix.\n  pixelMatrix.putPixels(canvas)\n}\n\nconst loadImage = canvas => {\n  // Wait until we have a canvas to draw on.\n  if (!canvas) return\n\n  // Create a new image element.\n  const image = new Image()\n\n  // When the image loads, resolve the promise\n  const onLoad = () => {\n    draw(image, canvas)\n  }\n\n  image.addEventListener('load', onLoad, false)\n\n  // Start loading the image\n  image.src = exampleImageUrl\n}\nreturn <canvas style={{ width: '50%', height: '50%', imageRendering: 'pixelated' }} ref={loadImage} />\n}}\n</Playground>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"animation-sampling-an-images-color-distribution\"}}>{`Animation: Sampling an image's color distribution`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`Pixel Matrix makes it easy to remix and algorithmically modify images. For example, here's how to create a new image by randomly sampling the colors of another image.`}</MDXTag>\n<Playground __codesandbox={`undefined`} __position={3} __code={'() => {\\n  const width = 25\\n  const height = 25\\n\\n  const draw = (colorPaletteImage, canvas) => {\\n    // Pixel Matrix can\\'t load data from images directly,\\n    // so we have to create an intermediate canvas element.\\n    const colorPaletteCanvas = document.createElement(\\'canvas\\')\\n    colorPaletteCanvas.width = colorPaletteImage.width\\n    colorPaletteCanvas.height = colorPaletteImage.height\\n    // Draw the image to the intermediate canvas.\\n    const context = colorPaletteCanvas.getContext(\\'2d\\')\\n    context.drawImage(colorPaletteImage, 0, 0)\\n\\n    // Instantiate a PixelMatrix from the canvas.\\n    // This will copy the width, height, and pixels\\n    // of the canvas into the pixel matrix.\\n    // This pixel matrix will store our color palette.\\n    const colorPalette = PixelMatrix.fromCanvas(colorPaletteCanvas)\\n\\n    // Create a new pixel matrix, then map its empty pixels to\\n    // randomly chosen pixels from our color palette.\\n    const pixelMatrix = new PixelMatrix(width, height).map(() =>\\n      colorPalette.getRandomPixel(),\\n    )\\n\\n    // Draw the image to our canvas using pixel matrix.\\n    pixelMatrix.putPixels(canvas)\\n\\n    // Create an animation loop that paints a random pixel with\\n    // a random color from our color palette every frame.\\n    const animate = () => {\\n      // Get a random point in our pixel matrix.\\n      const point = pixelMatrix.getRandomPoint()\\n\\n      // Get a random color from our color palette.\\n      const pixel = colorPalette.getRandomPixel()\\n\\n      // Set the random point to the random color.\\n      pixelMatrix.set(point, pixel)\\n\\n      // Draw to the canvas.\\n      pixelMatrix.putPixels(canvas)\\n\\n      // Ask the browser to call this function again.\\n      window.requestAnimationFrame(animate)\\n    }\\n\\n    // Kick off the animation loop.\\n    animate()\\n  }\\n\\n  const loadImage = canvas => {\\n    // Wait until we have a canvas to draw on.\\n    if (!canvas) return\\n\\n    // Create a new image element.\\n    const image = new Image()\\n\\n    // When the image loads, resolve the promise\\n    const onLoad = () => {\\n      draw(image, canvas)\\n    }\\n\\n    image.addEventListener(\\'load\\', onLoad, false)\\n\\n    // Start loading the image\\n    image.src = exampleImageUrl\\n  }\\n  return (\\n    <canvas\\n      width={width}\\n      height={height}\\n      style={{ width: \\'50%\\', height: \\'50%\\', imageRendering: \\'pixelated\\' }}\\n      ref={loadImage}\\n    />\\n  )\\n}'} __scope={{props: this ? this.props : props,PixelMatrix,exampleImageUrl}}>\n  {() => {\n    const width = 25\n    const height = 25\n    \n    const draw = (colorPaletteImage, canvas) => {\n      // Pixel Matrix can't load data from images directly,\n      // so we have to create an intermediate canvas element.\n      const colorPaletteCanvas = document.createElement('canvas')\n      colorPaletteCanvas.width = colorPaletteImage.width\n      colorPaletteCanvas.height = colorPaletteImage.height\n  // Draw the image to the intermediate canvas.\n  const context = colorPaletteCanvas.getContext('2d')\n  context.drawImage(colorPaletteImage, 0, 0)\n\n  // Instantiate a PixelMatrix from the canvas.\n  // This will copy the width, height, and pixels\n  // of the canvas into the pixel matrix.\n  // This pixel matrix will store our color palette.\n  const colorPalette = PixelMatrix.fromCanvas(colorPaletteCanvas)\n\n  // Create a new pixel matrix, then map its empty pixels to\n  // randomly chosen pixels from our color palette.\n  const pixelMatrix = new PixelMatrix(width, height).map(() => colorPalette.getRandomPixel())\n\n  // Draw the image to our canvas using pixel matrix.\n  pixelMatrix.putPixels(canvas)\n\n  // Create an animation loop that paints a random pixel with\n  // a random color from our color palette every frame.\n  const animate = () => {\n    // Get a random point in our pixel matrix.\n    const point = pixelMatrix.getRandomPoint()\n\n    // Get a random color from our color palette.\n    const pixel = colorPalette.getRandomPixel()\n\n    // Set the random point to the random color.\n    pixelMatrix.set(point, pixel)\n\n    // Draw to the canvas.\n    pixelMatrix.putPixels(canvas)\n\n    // Ask the browser to call this function again.\n    window.requestAnimationFrame(animate)\n  }\n\n  // Kick off the animation loop.\n  animate()\n}\n\nconst loadImage = canvas => {\n  // Wait until we have a canvas to draw on.\n  if (!canvas) return\n\n  // Create a new image element.\n  const image = new Image()\n\n  // When the image loads, resolve the promise\n  const onLoad = () => {\n    draw(image, canvas)\n  }\n\n  image.addEventListener('load', onLoad, false)\n\n  // Start loading the image\n  image.src = exampleImageUrl\n}\nreturn <canvas width={width} height={height} style={{ width: '50%', height: '50%', imageRendering: 'pixelated' }} ref={loadImage} />\n}}\n</Playground>\n           </MDXTag>\n  }\n}\n  "]}]}