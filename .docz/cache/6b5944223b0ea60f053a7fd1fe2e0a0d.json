{"remainingRequest":"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-loader/lib/index.js?{\"presets\":[[\"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-preset-docz/dist/index.js\",{\"flow\":false,\"typescript\":true,\"parseProps\":false}]],\"plugins\":[[\"/Users/noisemachines/dev/pixel-matrix/node_modules/docz-utils/lib/named-asset-import.js\",{\"loaderMap\":{\"svg\":{\"ReactComponent\":\"@svgr/webpack?-prettier,-svgo![path]\"}}}],\"/Users/noisemachines/dev/pixel-matrix/node_modules/react-hot-loader/babel.js\"],\"babelrc\":false,\"cacheCompression\":false,\"compact\":false}!/Users/noisemachines/dev/pixel-matrix/node_modules/react-docgen-typescript-loader/dist/index.js?{}!/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts","dependencies":[{"path":"/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts","mtime":1547746163189},{"path":"/Users/noisemachines/dev/pixel-matrix/node_modules/cache-loader/dist/cjs.js","mtime":1547744876783},{"path":"/Users/noisemachines/dev/pixel-matrix/node_modules/babel-loader/lib/index.js","mtime":1547744876677},{"path":"/Users/noisemachines/dev/pixel-matrix/node_modules/react-docgen-typescript-loader/dist/index.js","mtime":1547744877189}],"contextDependencies":[],"result":["(function () {\n  var enterModule = require('react-hot-loader').enterModule;\n\n  enterModule && enterModule(module);\n})();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar RGBA = {\n  channels: 4\n};\nexport var COLOR_PROFILES = {\n  RGBA: RGBA\n};\n\nvar isEven = function isEven(n) {\n  return n % 2 === 0;\n};\n\nvar EMPTY_PIXEL = {\n  red: 0,\n  green: 0,\n  blue: 0,\n  alpha: 0\n};\nexport var vonNeumannOffsets = [{\n  x: -1,\n  y: 0\n}, {\n  x: 1,\n  y: 0\n}, {\n  x: 0,\n  y: -1\n}, {\n  x: 0,\n  y: 1\n}];\nexport var mooreOffsets = [];\n\nfor (var _x = -1; _x <= 1; _x++) {\n  for (var _y = -1; _y <= 1; _y++) {\n    if (_x === 0 && _y === 0) {\n      continue;\n    }\n\n    mooreOffsets.push({\n      x: _x,\n      y: _y\n    });\n  }\n}\n\nvar PixelMatrix =\n/*#__PURE__*/\nfunction () {\n  _createClass(PixelMatrix, [{\n    key: \"pixelMatrix\",\n    get: function get() {\n      if (!this._pixelMatrix) {\n        var _pixelMatrix = new Array(this.width);\n\n        this.forEach(function (pixel, point) {\n          if (!_pixelMatrix[point.x]) _pixelMatrix[point.x] = [];\n          _pixelMatrix[point.x][point.y] = pixel;\n        });\n        this._pixelMatrix = _pixelMatrix;\n      }\n\n      return this._pixelMatrix;\n    }\n  }, {\n    key: \"channels\",\n    get: function get() {\n      return this.colorProfile.channels;\n    }\n  }, {\n    key: \"shape\",\n    get: function get() {\n      return [this.width, this.height];\n    }\n  }, {\n    key: \"countPixels\",\n    get: function get() {\n      return this.width * this.height;\n    }\n  }], [{\n    key: \"fromCanvas\",\n    value: function fromCanvas(canvas) {\n      var context = canvas.getContext('2d');\n      var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n      return new PixelMatrix(canvas.width, canvas.height, COLOR_PROFILES.RGBA, imageData.data);\n    }\n  }]);\n\n  function PixelMatrix(width, height) {\n    var colorProfile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RGBA;\n    var pixels = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, PixelMatrix);\n\n    this.width = width;\n    this.height = height;\n    this.colorProfile = colorProfile;\n    this.pixels = void 0;\n    this._pixelMatrix = void 0;\n    var pixelsLength = width * height * colorProfile.channels;\n\n    if (pixels === undefined) {\n      pixels = new Uint8ClampedArray(pixelsLength);\n    } else {\n      if (pixelsLength !== pixels.length) {\n        throw new Error(\"Expected pixels to have length \".concat(pixelsLength, \" (width * height * colorProfile.channels) but got \").concat(pixels.length, \" instead.\"));\n      }\n    }\n\n    this.pixels = pixels;\n  }\n\n  _createClass(PixelMatrix, [{\n    key: \"get\",\n    value: function get(point) {\n      if (!this.contains(point)) {\n        throw new Error(\"This pixel matrix doesn't contain the point \".concat(point, \".\"));\n      }\n\n      var i = this.getIndex(point);\n      var channels = [];\n\n      for (var channelOffset = 0; channelOffset < this.colorProfile.channels; channelOffset++) {\n        var channel = this.pixels[i + channelOffset];\n        if (!channel) return EMPTY_PIXEL;\n        channels.push(channel);\n      }\n\n      var red = channels[0],\n          green = channels[1],\n          blue = channels[2],\n          alpha = channels[3];\n      return {\n        red: red,\n        green: green,\n        blue: blue,\n        alpha: alpha\n      };\n    }\n  }, {\n    key: \"getRandomPoint\",\n    value: function getRandomPoint() {\n      var x = Math.round(Math.random() * (this.width - 1));\n      var y = Math.round(Math.random() * (this.height - 1));\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"getRandomPixel\",\n    value: function getRandomPixel() {\n      var randomPoint = this.getRandomPoint();\n      return this.get(randomPoint);\n    }\n  }, {\n    key: \"getVonNeumannNeighboringPixels\",\n    value: function getVonNeumannNeighboringPixels(point) {\n      return this.getNeighboringPixels(point, vonNeumannOffsets);\n    }\n  }, {\n    key: \"getVonNeumannNeighboringPoints\",\n    value: function getVonNeumannNeighboringPoints(point) {\n      return this.getNeighbors(point, vonNeumannOffsets);\n    }\n  }, {\n    key: \"getMooreNeighboringPixels\",\n    value: function getMooreNeighboringPixels(point) {\n      return this.getNeighboringPixels(point, mooreOffsets);\n    }\n  }, {\n    key: \"getMooreNeighboringPoints\",\n    value: function getMooreNeighboringPoints(point) {\n      return this.getNeighbors(point, mooreOffsets);\n    }\n  }, {\n    key: \"getNeighboringPixels\",\n    value: function getNeighboringPixels(point, neighborhood) {\n      var _this = this;\n\n      return this.getNeighbors(point, neighborhood).map(function (neighbor) {\n        return _this.get(neighbor);\n      });\n    }\n  }, {\n    key: \"getNeighbors\",\n    value: function getNeighbors(point, neighborhood) {\n      var _this2 = this;\n\n      var neighbors = [];\n      neighborhood.forEach(function (offset) {\n        var neighbor = {\n          x: point.x + offset.x,\n          y: point.y + offset.y\n        };\n\n        if (_this2.contains(neighbor)) {\n          neighbors.push(neighbor);\n        }\n      });\n      return neighbors;\n    }\n  }, {\n    key: \"set\",\n    value: function set(point, pixel) {\n      var red = pixel.red,\n          green = pixel.green,\n          blue = pixel.blue,\n          alpha = pixel.alpha;\n      var i = this.getIndex(point);\n      this.pixels[i] = red;\n      this.pixels[i + 1] = green;\n      this.pixels[i + 2] = blue;\n      this.pixels[i + 3] = alpha;\n      this.pixelMatrix[point.x][point.y] = pixel;\n    }\n  }, {\n    key: \"randomDitherFrom\",\n    value: function randomDitherFrom(newMatrix) {\n      var _this3 = this;\n\n      var samples = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n\n      var _loop = function _loop(_) {\n        var point = _this3.getRandomPoint();\n\n        var newPixel = newMatrix.get(point);\n        var p = newPixel;\n        var darkeningFactor = 0;\n\n        if (Math.random() > 0.5) {\n          p = {\n            red: newPixel.red - darkeningFactor,\n            green: newPixel.green - darkeningFactor,\n            blue: newPixel.blue - darkeningFactor,\n            alpha: 255\n          };\n        }\n\n        _this3.getVonNeumannNeighboringPoints(point).forEach(function (neighbor) {\n          _this3.set(neighbor, p);\n        });\n      };\n\n      for (var _ = 0; _ < samples; _++) {\n        _loop(_);\n      }\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(point) {\n      var x = point.x,\n          y = point.y;\n\n      if (!this.contains(point)) {\n        throw new Error(\"Expected x and y to be less than or equal to (\".concat(this.width, \", \").concat(this.height, \") but was actually (\").concat(x, \", \").concat(y, \")\"));\n      }\n\n      return y * (this.width * this.channels) + x * this.channels;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      for (var _y2 = 0; _y2 < this.height; _y2++) {\n        for (var _x2 = 0; _x2 < this.width; _x2++) {\n          var _point = Object.freeze({\n            x: _x2,\n            y: _y2\n          });\n\n          var _pixel = this.get(_point);\n\n          fn(_pixel, _point, this);\n        }\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn) {\n      var newPixelMatrix = new PixelMatrix(this.width, this.height, this.colorProfile);\n      this.forEach(function (pixel, point, pixelMatrix) {\n        var newPixel = fn(pixel, point, pixelMatrix);\n        newPixelMatrix.set(point, newPixel);\n      });\n      return newPixelMatrix;\n    }\n  }, {\n    key: \"normalizedMap\",\n    value: function normalizedMap(fn) {\n      var _this4 = this;\n\n      return this.map(function (pixel, point, pixelMatrix) {\n        var normalizedPoint = {\n          x: point.x / _this4.width,\n          y: point.y / _this4.height\n        };\n        return fn(pixel, normalizedPoint, pixelMatrix);\n      });\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(fn, startingValue) {\n      var total = startingValue;\n      this.forEach(function (pixel, point) {\n        total = fn(total, pixel, point);\n      });\n      return total;\n    }\n  }, {\n    key: \"getWindow\",\n    value: function getWindow(center, width, height) {\n      if (isEven(width)) {\n        throw new Error(\"Expected an odd window width, but got \".concat(width));\n      }\n\n      if (isEven(height)) {\n        throw new Error(\"Expected an odd window height, but got \".concat(height));\n      }\n\n      var xRadius = (width - 1) / 2;\n      var yRadius = (height - 1) / 2;\n      var windowMatrix = new PixelMatrix(width, height, this.colorProfile);\n\n      for (var yOffset = -yRadius; yOffset <= yRadius; yOffset++) {\n        for (var xOffset = -xRadius; xOffset <= xRadius; xOffset++) {\n          var _x3 = center.x + xOffset;\n\n          var _y3 = center.y + yOffset;\n\n          var _point2 = {\n            x: _x3,\n            y: _y3\n          };\n\n          var _pixel2 = this.contains(_point2) ? this.get(_point2) : EMPTY_PIXEL;\n\n          var pointInWindow = {\n            x: xOffset + xRadius,\n            y: yOffset + yRadius\n          };\n          windowMatrix.set(pointInWindow, _pixel2);\n        }\n      }\n\n      return windowMatrix;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(point) {\n      return point.x >= 0 && point.x < this.width && point.y >= 0 && point.y < this.height;\n    }\n  }, {\n    key: \"toImageData\",\n    value: function toImageData() {\n      return new ImageData(this.pixels, this.width, this.height);\n    }\n  }, {\n    key: \"putPixels\",\n    value: function putPixels(canvas) {\n      if (canvas.width !== this.width || canvas.height !== this.height) {\n        throw new Error(\"Expected canvas shape and PixelMatrix shape to be the same, but canvas shape was [\".concat(canvas.width, \", \").concat(canvas.height, \"] and PixelMatrix shape was \").concat(this.shape, \".\"));\n      }\n\n      var context = canvas.getContext('2d');\n      context.putImageData(this.toImageData(), 0, 0);\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      var x = Math.floor(this.width / 2);\n      var y = Math.floor(this.height / 2);\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return PixelMatrix;\n}();\n\nexport { PixelMatrix as default };\n;\n\n(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n\n  var leaveModule = require('react-hot-loader').leaveModule;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(RGBA, \"RGBA\", \"/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts\");\n  reactHotLoader.register(COLOR_PROFILES, \"COLOR_PROFILES\", \"/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts\");\n  reactHotLoader.register(isEven, \"isEven\", \"/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts\");\n  reactHotLoader.register(EMPTY_PIXEL, \"EMPTY_PIXEL\", \"/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts\");\n  reactHotLoader.register(vonNeumannOffsets, \"vonNeumannOffsets\", \"/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts\");\n  reactHotLoader.register(mooreOffsets, \"mooreOffsets\", \"/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts\");\n  reactHotLoader.register(PixelMatrix, \"PixelMatrix\", \"/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts\");\n  leaveModule(module);\n})();\n\n;",{"version":3,"sources":["/Users/noisemachines/dev/pixel-matrix/source/PixelMatrix.ts"],"names":["RGBA","channels","COLOR_PROFILES","isEven","n","EMPTY_PIXEL","red","green","blue","alpha","vonNeumannOffsets","x","y","mooreOffsets","push","PixelMatrix","_pixelMatrix","pixelMatrix","Array","width","forEach","pixel","point","colorProfile","height","canvas","context","getContext","imageData","getImageData","data","pixels","pixelsLength","undefined","Uint8ClampedArray","length","Error","contains","i","getIndex","channelOffset","channel","Math","round","random","randomPoint","getRandomPoint","get","getNeighboringPixels","getNeighbors","neighborhood","map","neighbor","neighbors","offset","newMatrix","samples","_","newPixel","p","darkeningFactor","getVonNeumannNeighboringPoints","set","fn","Object","freeze","newPixelMatrix","normalizedPoint","startingValue","total","center","xRadius","yRadius","windowMatrix","yOffset","xOffset","pointInWindow","ImageData","shape","putImageData","toImageData","floor"],"mappings":"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","sourcesContent":["interface ColorProfile {\n  channels: number\n}\n\nconst RGBA: ColorProfile = {\n  channels: 4\n}\n\nexport const COLOR_PROFILES = {\n  RGBA\n}\n\nexport type Shape = [number, number]\n\nexport interface Pixel {\n  red: number,\n  green: number,\n  blue: number,\n  alpha: number\n}\n\nexport interface Point {\n  x: number,\n  y: number\n}\n\nexport interface PixelForEacher {\n  (pixel: Pixel, point: Point, pixelMatrix: PixelMatrix): void\n}\n\nexport interface PixelMapper {\n  (pixel: Pixel, point: Point, pixelMatrix: PixelMatrix): Pixel\n}\n\nexport interface PixelReducer<T> {\n  (total: T, pixel: Pixel, point: Point): T\n}\n\nconst isEven = (n: number) => n % 2 === 0\n\nconst EMPTY_PIXEL: Pixel = {\n  red: 0,\n  green: 0,\n  blue: 0,\n  alpha: 0\n}\n\nexport const vonNeumannOffsets: Point[] = [\n  { x: -1, y: 0 },\n  { x: 1, y: 0 },\n  { x: 0, y: -1 },\n  { x: 0, y: 1 }\n]\n\nexport const mooreOffsets: Point[] = []\n\nfor (let x = -1; x <= 1; x++) {\n  for (let y = -1; y <= 1; y++) {\n    if (x === 0 && y === 0) {\n      continue\n    }\n    mooreOffsets.push({ x, y })\n  }\n}\n\nexport default class PixelMatrix {\n  static fromCanvas(canvas: HTMLCanvasElement) {\n    const context: CanvasRenderingContext2D = canvas.getContext('2d')!\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height)\n    return new PixelMatrix(\n      canvas.width,\n      canvas.height,\n      COLOR_PROFILES.RGBA,\n      imageData.data\n    )\n  }\n  pixels: Uint8ClampedArray\n  private _pixelMatrix: Pixel[][] | undefined\n  get pixelMatrix() {\n    if (!this._pixelMatrix) {\n      const pixelMatrix = new Array(this.width)\n      this.forEach((pixel, point) => {\n        if (!pixelMatrix[point.x]) pixelMatrix[point.x] = []\n        pixelMatrix[point.x][point.y] = pixel\n      })\n      this._pixelMatrix = pixelMatrix\n    }\n\n    return this._pixelMatrix\n  }\n  get channels() {\n    return this.colorProfile.channels\n  }\n  get shape(): Shape {\n    return [this.width, this.height]\n  }\n  get countPixels(): number {\n    return this.width * this.height\n  }\n  constructor(public width: number, public height: number, public colorProfile: ColorProfile = RGBA, pixels?: Uint8ClampedArray) {\n    const pixelsLength =\n      width * height * colorProfile.channels\n    if (pixels === undefined) {\n      pixels = new Uint8ClampedArray(pixelsLength)\n    } else {\n      if (pixelsLength !== pixels.length) {\n        throw new Error(`Expected pixels to have length ${pixelsLength} (width * height * colorProfile.channels) but got ${pixels.length} instead.`)\n      }\n    }\n    this.pixels = pixels\n  }\n  get(point: Point): Pixel {\n    if (!this.contains(point)) {\n      throw new Error(`This pixel matrix doesn't contain the point ${point}.`)\n    }\n    const i = this.getIndex(point)\n\n    let channels: number[] = []\n    for (let channelOffset = 0; channelOffset < this.colorProfile.channels; channelOffset++) {\n      const channel = this.pixels[i + channelOffset]\n      if (!channel) return EMPTY_PIXEL\n      channels.push(channel)\n    }\n\n    const [red, green, blue, alpha] = channels\n    return { red, green, blue, alpha }\n  }\n  getRandomPoint(): Point {\n    const x = Math.round(Math.random() * (this.width - 1))\n    const y = Math.round(Math.random() * (this.height - 1))\n    return { x, y }\n  }\n  getRandomPixel(): Pixel {\n    const randomPoint = this.getRandomPoint()\n    return this.get(randomPoint)\n  }\n  getVonNeumannNeighboringPixels(point: Point): Pixel[] {\n    return this.getNeighboringPixels(point, vonNeumannOffsets)\n  }\n  getVonNeumannNeighboringPoints(point: Point): Point[] {\n    return this.getNeighbors(point, vonNeumannOffsets)\n  }\n  getMooreNeighboringPixels(point: Point): Pixel[] {\n    return this.getNeighboringPixels(point, mooreOffsets)\n  }\n  getMooreNeighboringPoints(point: Point): Point[] {\n    return this.getNeighbors(point, mooreOffsets)\n  }\n  getNeighboringPixels(point: Point, neighborhood: Point[]): Pixel[] {\n    return this.getNeighbors(point, neighborhood).map(neighbor => this.get(neighbor))\n  }\n  getNeighbors(point: Point, neighborhood: Point[]): Point[] {\n    const neighbors: Point[] = []\n    neighborhood.forEach(offset => {\n      const neighbor = {\n        x: point.x + offset.x,\n        y: point.y + offset.y\n      }\n      if (this.contains(neighbor)) {\n        neighbors.push(neighbor)\n      }\n    })\n    return neighbors\n  }\n  set(point: Point, pixel: Pixel): void {\n    const { red, green, blue, alpha } = pixel\n    const i = this.getIndex(point)\n    this.pixels[i] = red\n    this.pixels[i + 1] = green\n    this.pixels[i + 2] = blue\n    this.pixels[i + 3] = alpha\n    this.pixelMatrix[point.x][point.y] = pixel\n  }\n  randomDitherFrom(newMatrix: PixelMatrix, samples = 1000) {\n    for (let _ = 0; _ < samples; _++) {\n      const point = this.getRandomPoint()\n      const newPixel = newMatrix.get(point)\n      let p = newPixel\n      const darkeningFactor = 0\n      if (Math.random() > 0.5) {\n        p = {\n          red: newPixel.red - darkeningFactor,\n          green: newPixel.green - darkeningFactor,\n          blue: newPixel.blue - darkeningFactor,\n          alpha: 255\n        }\n      }\n      this.getVonNeumannNeighboringPoints(point).forEach(neighbor => {\n        this.set(neighbor, p)\n      })\n    }\n  }\n  protected getIndex(point: Point): number {\n    const { x, y } = point\n    if (!this.contains(point)) {\n      throw new Error(\n        `Expected x and y to be less than or equal to (${this.width}, ${\n        this.height\n        }) but was actually (${x}, ${y})`\n      )\n    }\n    return y * (this.width * this.channels) + x * this.channels\n  }\n  forEach(fn: PixelForEacher) {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        const point = Object.freeze({ x, y })\n        const pixel = this.get(point)\n        fn(pixel, point, this)\n      }\n    }\n  }\n  map(fn: PixelMapper) {\n    const newPixelMatrix = new PixelMatrix(\n      this.width,\n      this.height,\n      this.colorProfile\n    )\n    this.forEach((pixel, point, pixelMatrix) => {\n      const newPixel = fn(pixel, point, pixelMatrix)\n      newPixelMatrix.set(point, newPixel)\n    })\n    return newPixelMatrix\n  }\n  normalizedMap(fn: PixelMapper) {\n    return this.map((pixel, point, pixelMatrix) => {\n      const normalizedPoint = {\n        x: point.x / this.width,\n        y: point.y / this.height\n      }\n      return fn(pixel, normalizedPoint, pixelMatrix)\n    })\n  }\n  reduce<T>(fn: PixelReducer<T>, startingValue: T) {\n    let total = startingValue\n    this.forEach((pixel, point) => {\n      total = fn(total, pixel, point)\n    })\n    return total\n  }\n  getWindow(center: Point, width: number, height: number): PixelMatrix {\n    if (isEven(width)) {\n      throw new Error(`Expected an odd window width, but got ${width}`)\n    }\n    if (isEven(height)) {\n      throw new Error(`Expected an odd window height, but got ${height}`)\n    }\n    const xRadius = (width - 1) / 2\n    const yRadius = (height - 1) / 2\n    const windowMatrix = new PixelMatrix(width, height, this.colorProfile)\n    for (let yOffset = -yRadius; yOffset <= yRadius; yOffset++) {\n      for (let xOffset = -xRadius; xOffset <= xRadius; xOffset++) {\n        let x = center.x + xOffset\n        let y = center.y + yOffset\n        const point = { x, y }\n        const pixel = this.contains(point) ? this.get(point) : EMPTY_PIXEL\n        const pointInWindow = { x: xOffset + xRadius, y: yOffset + yRadius }\n        windowMatrix.set(pointInWindow, pixel)\n      }\n    }\n    return windowMatrix\n  }\n  contains(point: Point): boolean {\n    return (\n      point.x >= 0 &&\n      point.x < this.width &&\n      point.y >= 0 &&\n      point.y < this.height\n    )\n  }\n  toImageData() {\n    return new ImageData(this.pixels, this.width, this.height)\n  }\n  putPixels(canvas: HTMLCanvasElement) {\n    if (canvas.width !== this.width || canvas.height !== this.height) {\n      throw new Error(\n        `Expected canvas shape and PixelMatrix shape to be the same, but canvas shape was [${\n        canvas.width\n        }, ${canvas.height}] and PixelMatrix shape was ${\n        this.shape\n        }.`\n      )\n    }\n    const context = canvas.getContext('2d')!\n    context.putImageData(this.toImageData(), 0, 0)\n  }\n  getCenter(): Point {\n    const x = Math.floor(this.width / 2)\n    const y = Math.floor(this.height / 2)\n    return { x, y }\n  }\n}"]}]}