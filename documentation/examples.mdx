---
name: Examples
route: /examples
---

import { Playground } from 'docz'
import PixelMatrix from '../built/PixelMatrix'
import exampleImageUrl from './kawase.small.jpg'

# Examples

Pixel Matrix is a tiny library that provides a nice interface for playing with pixels.

## Drawing a pixel

Pixel Matrix has a straightforward imperative API. Points and colors are just JSON objects. Use `.set(point, color)` to assign an RGBA value to a point and `.get(point)` to retrieve it.

<Playground>
  {() => {
    const width = 1
    const height = 1

    const draw = canvas => {
      // Make sure we have a canvas to draw on.
      if (!canvas) return

      // Initialize a new pixel matrix.
      const pixelMatrix = new PixelMatrix(width, height)

      // Points are just objects.
      const point = { x: 0, y: 0 }

      // So are colors.
      const color = {
        red: 222,
        green: 98,
        blue: 98,
        alpha: 255
      }

      // Set (0, 0) to a pleasant coral.
      pixelMatrix.set(point, color)

      // Render the current contents of the pixel matrix to the canvas.
      pixelMatrix.putPixels(canvas)
    }

    return <canvas
      width={width}
      height={height}
      style={{ width: '20%', height: '20%', imageRendering: 'pixelated' }} ref={draw} />

}}

</Playground>

## Drawing a gradient

For more complex work, Pixel Matrix also offers functional building blocks like `forEach`, `map`, and `reduce`.

<Playground>
  {() => {
    // Start the gradient with a pleasant coral red.
    const startColor = {
      red: 222,
      green: 98,
      blue: 98,
      alpha: 255
    }
    
    // End it with a warm, citrus-y sunset.
    const endColor = {
      red: 255,
      green: 184,
      blue: 140,
      alpha: 255
    }

    // A helper function for gradually transitioning
    // between two numbers. When progress is 0
    // it returns the starting number, and when progress is 1
    // it returns the ending number. When progress is 0.5,
    // it returns the number halfway between the two.
    const lerp = (start, end, progress) => {
      const distance = end - start
      const interpolated = start + (distance * progress)
      return Math.round(interpolated)
    }

    // Applies a linear interpolation to each channel of a color.
    const lerpColor = (start, end, progress) => {
      return {
        red: lerp(start.red, end.red, progress),
        green: lerp(start.green, end.green, progress),
        blue: lerp(start.blue, end.blue, progress),
        alpha: lerp(start.alpha, end.alpha, progress)
      }
    }

    const width = 10
    const height = 1

    const draw = canvas => {
      // Wait until we have a canvas to draw on.
      if (!canvas) return

      const pixelMatrix = new PixelMatrix(width, height)

      // .map transforms each pixel by running it through
      // the supplied callback. The new pixel values are
      // used to populate a new pixel matrix instance.
      const gradient = pixelMatrix.map((currentPixel, currentPoint) => {
        const progress = currentPoint.x / width

        // Use lerp ("linear interpolation") to transition
        // gradually between our start color and end color.
        const newPixel = lerpColor(startColor, endColor, progress)
        return newPixel
      })
      gradient.putPixels(canvas)
    }

    return <canvas width={width} height={height} style={{ width: '100%', height: '20%', imageRendering: 'pixelated' }} ref={draw} />

}}

</Playground>

## Load an image

Pixel Matrix can load and interact with images by using an intermediate `canvas` element.

<Playground>
  {() => {
    const draw = (image, canvas) => {
      // Pixel Matrix can't load data from images directly,
      // so we have to create an intermediate canvas element.
      const imageCanvas = document.createElement('canvas')
      imageCanvas.width = image.width
      imageCanvas.height = image.height

      // Draw the image to the intermediate canvas.
      const context = imageCanvas.getContext('2d')
      context.drawImage(image, 0, 0)

      // Instantiate a PixelMatrix from the canvas.
      // This will copy the width, height, and pixels
      // of the canvas into the pixel matrix.
      const pixelMatrix = PixelMatrix.fromCanvas(imageCanvas)

      // Set our original canvas element to the same size as the image.
      canvas.width = image.width
      canvas.height = image.height

      // Draw the image to our original canvas using pixel matrix.
      pixelMatrix.putPixels(canvas)
    }

    const loadImage = canvas => {
      // Wait until we have a canvas to draw on.
      if (!canvas) return

      // Create a new image element.
      const image = new Image()

      // When the image loads, resolve the promise
      const onLoad = () => {
        draw(image, canvas)
      }

      image.addEventListener('load', onLoad, false)

      // Start loading the image
      image.src = exampleImageUrl
    }

return <canvas style={{ width: '50%', height: '50%', imageRendering: 'pixelated' }} ref={loadImage} />
}}

</Playground>

## Animation: Sampling an image's color distribution

Pixel Matrix makes it easy to remix and algorithmically modify images. For example, here's how to create a new image by randomly sampling the colors of another image.

<Playground>
  {() => {
    const width = 25
    const height = 25
    
    const draw = (colorPaletteImage, canvas) => {
      // Pixel Matrix can't load data from images directly,
      // so we have to create an intermediate canvas element.
      const colorPaletteCanvas = document.createElement('canvas')
      colorPaletteCanvas.width = colorPaletteImage.width
      colorPaletteCanvas.height = colorPaletteImage.height

      // Draw the image to the intermediate canvas.
      const context = colorPaletteCanvas.getContext('2d')
      context.drawImage(colorPaletteImage, 0, 0)

      // Instantiate a PixelMatrix from the canvas.
      // This will copy the width, height, and pixels
      // of the canvas into the pixel matrix.
      // This pixel matrix will store our color palette.
      const colorPalette = PixelMatrix.fromCanvas(colorPaletteCanvas)

      // Create a new pixel matrix, then map its empty pixels to
      // randomly chosen pixels from our color palette.
      const pixelMatrix = new PixelMatrix(width, height).map(() => colorPalette.getRandomPixel())

      // Draw the image to our canvas using pixel matrix.
      pixelMatrix.putPixels(canvas)

      // Create an animation loop that paints a random pixel with
      // a random color from our color palette every frame.
      const animate = () => {
        // Get a random point in our pixel matrix.
        const point = pixelMatrix.getRandomPoint()

        // Get a random color from our color palette.
        const pixel = colorPalette.getRandomPixel()

        // Set the random point to the random color.
        pixelMatrix.set(point, pixel)

        // Draw to the canvas.
        pixelMatrix.putPixels(canvas)

        // Ask the browser to call this function again.
        window.requestAnimationFrame(animate)
      }

      // Kick off the animation loop.
      animate()
    }

    const loadImage = canvas => {
      // Wait until we have a canvas to draw on.
      if (!canvas) return

      // Create a new image element.
      const image = new Image()

      // When the image loads, resolve the promise
      const onLoad = () => {
        draw(image, canvas)
      }

      image.addEventListener('load', onLoad, false)

      // Start loading the image
      image.src = exampleImageUrl
    }

return <canvas width={width} height={height} style={{ width: '50%', height: '50%', imageRendering: 'pixelated' }} ref={loadImage} />
}}

</Playground>
